\chapter{Preface}
\label{ch:Preface}

Computers are logic in action. Literally.
Many computer components are realizations of formulas in logic,
and when activated by Boolean inputs, those components
compute the value of the logic formula that they actualize.
Software, too, is an exhibit in logic.
A software component is a formula in a formal language
with underpinnings in logic,
and in some programming languages a software component
is, literally, an algebraic formula.
A big formula, but a formula nevertheless.

Therefore, people studying computer science
can derive substantial benefit from a study of logic,
and it is perhaps for that reason most computer science students 
are exposed to logic in the course of their education.
In many cases, maybe most cases, this exposure comes
in the form of a few lectures and a problem set or two
in a discrete math class. The applications of logic that
they see usually have more to do with traditional mathematics
than with computer science. Even when the discrete math class
is ``discrete math for computer science,'' the computer science
part has more to do with writing programs to solve problems
in traditional mathematics or compute examples of
mathematical objects than it has to do with
concepts in computer science.
We take the view that computer science students will
benefit from a substantially more extensive and rigorous
exposure to logic and especially to applications of
logic in their chosen field of study.

This book focusses directly on central issues
in computer science.
It frames the discussion in terms of logic,
and it applies logic to problems in the domain of computer science.
Hardware components, software components,
testing and verification of properties, analysis of algorithms,
to name a few.
Instead of illustrating mathematical induction by  proving
that a formula represents the sum of a sequence of numbers,
we begin with an inductive proof of an important property of an operator
that concatenates lists, and proceed to verify properties of
many other software and hardware components.
It's the same old mathematical induction, but presented
in the context of things of particular interest to
students of computer science.
The logic of induction is at the forefront, 
unobscured by the clever tricks of numeric algebra
that many exercises on induction require in
presentations of the idea that are grounded in topics
of particular interest to mathematicians.

We hope that readers of this text will be inclined
to devote a substantial effort, on the order
of what it takes to absorb a few dozen fifty-minute
lectures at the college level,
to understanding some important problems in computer science and
in pursuing solutions to many of those problems through formal reasoning.
Formality is a watchword in this presentation, even to the
point of the mechanized formalism of a partially automated proof engine
that checks proofs to the last detail and is sometimes able
to bridge, on its own, the small gaps that most mathematical
proofs leave open, even when they employ the traditional amount
of mathematical rigor.

We chose ACL2 as the proof engine for this work
because in our judgment it provides a more accessible
introduction to mechanized formalism than any other
available proof engine. We do not anticipate that any
reader will become an expert user of ACL2, or even 
an accomplished user. We bring ACL2 into the discussion 
to give readers a chance to see how logic, including mechanized logic, 
can benefit practicing software and hardware designers.
If at some point they want to realize those benefits in
large-scale projects, they will need to learn a lot more
about ACL2 or some other mechanized logic than it will
be possible to glean from this introduction.

Logic is the central topic of the text, but not the only topic.
Readers interested in the broad outlines of computer science
will find the material useful in that pursuit. 
We think the text can provide a basis for a serious introduction
to computer science concepts, both for computer science students
and for students in other fields who want to know
what computer science is about.
Earlier versions of the text have been used many times
in three types of courses: logic for computer scientists,
introduction to computer science, and computer science for
students in other disciplines. 
We believe the text has served well in all three of these realms.

There are no prerequisites beyond college prep high-school math. 
Even less, really.
An understanding of high-school algebra is helpful, 
but no experience with geometry, trigonometry, or calculus is needed.
Computer programming is not a prerequisite, either, 
and based on experience with the material in the classroom, 
programming experience is not especially helpful 
because it rarely addresses the equation-based model of computation that 
informs this text. In fact, we have found that the approach of the text
tends to level the playing ground, both between people with programming 
experience and those without it and between genders.

The required learning is far from easy. 
Successful students will have to do a lot of hard thinking 
to work their way through a few dozen of the exercises in the text, 
and they will surely need to do a few dozen exercises to grasp the concepts. 
Reading alone won't be enough.
Fortunately, the work pays off, both in terms of immediate satisfaction
and in the long term, if the testimonies of former students are a
reliable measure.
We hope readers will take some pleasure in working their way through
the book, and that they will find what they learn 
edifying as they move forward to other projects.
\\
\\
\emph{Santa Cruz, California}   \hfill Rex Page \\
\emph{Laramie, Wyoming}         \hfill Ruben Gamboa \\
\emph{January 2018}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
