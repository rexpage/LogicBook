\chapter{Preface}
\label{ch:Preface}

Computers are logic in action. Literally.
Many computer components are realizations of formulas in logic,
and when activated by Boolean signals, those components
compute the value of the logic formula that they actualize.
Software, too, is an exhibit in logic.
A software component is a specification in a formal language
with underpinnings in logic,
and in some programming languages a software component
is, literally, an algebraic formula.
A big formula, but a formula nevertheless.

Therefore, people studying computer science
can derive substantial benefit from a study of logic,
and it is perhaps for that reason most computer science students
are exposed to logic during their education.
In many cases, maybe most cases, this exposure comes
in the form of a few lectures and a problem set or two
in a discrete math course. The applications of logic that
they see usually have more to do with traditional mathematics
than with computer science. Even when the discrete math course
is ``discrete math for computer science,'' the computer science
part often has more to do with writing programs to solve problems
in traditional mathematics or to compute examples of
mathematical objects than it has to do with
concepts in computer science.
We think computer science students will
benefit from a substantially more extensive and rigorous
exposure to logic and to seeing many applications of
logic in their chosen field of study.
All the examples in this text arise from issues in computer science.

This book focusses directly on central issues
in computer science.
It frames the discussion in terms of logic,
and it applies logic to problems in the domain of computer science.
Hardware components, software components,
testing and verification, and analysis of algorithms
are some examples.
Instead of illustrating mathematical induction by proving
that a formula represents the sum of a sequence of numbers,
we begin with an inductive proof of an important property of
a software component that concatenates lists,
and we proceed to verify properties of
many other software and hardware components.
It's the same old mathematical induction, but presented
in the context of topics that interest
students of computer science.
The logic of induction is at the forefront,
unobscured by the clever tricks of numeric algebra
that many exercises on induction require in
discussions of the idea that are grounded in topics
of particular interest to mathematicians.

We hope that readers will be inclined
to devote a substantial effort, on the order
of what it takes to absorb a few dozen fifty-minute
lectures at the college level,
to understand some important problems in computer science and
to pursue solutions to many of those problems through formal reasoning.
Formalism is a watchword in this presentation, even to the
point of using the mechanized logic of a partially automated proof engine,
ACL2, that checks proofs to the last detail and can sometimes 
bridge, on its own, gaps that mathematical
proofs often leave open, even when they employ traditional
mathematical rigor.

We chose ACL2 as the proof engine for this work
because in our judgment it provides a more accessible
introduction to mechanized formalism than any other
available proof engine. We do not anticipate that any
reader will become an accomplished ACL2 user,
much less an ACL2 expert. We bring ACL2 into the discussion
to show how logic, including mechanized logic,
can benefit practicing software and hardware engineers.
If at some point readers want to realize those benefits in
large-scale projects, they will need to learn a lot more
about ACL2 or some other mechanized logic than it will
be possible to glean from this introduction.
In early classroom usage of this material,
we introduced formal methods using a traditional algebraic notation,
without a mechanized logic, but most students seem more comfortable
when formal methods are backed up by software tools
that check proofs and provide some aid with proof details.

Logic is the central topic of the text, but not the only topic.
Readers interested in the broad outlines of computer science
will find material useful in that pursuit.
We think the text can provide a basis for a serious introduction
to computer science concepts, both for computer science students
and for students in other fields who want to know
what computer science is about.
Earlier versions of the text have been used many times,
both by the authors and by other instructors,
as the primary text in two types of courses: logic for computer science
and introduction to computer science for both computer science students
and students in other disciplines. It has been used as a supplementary
text in discrete math courses for computer science students.
The text has served well in all three realms.

There are no prerequisites beyond college prep high-school math.
Even less, really.
High-school algebra is helpful,
but no geometry, trigonometry, or calculus is needed.
Computer programming is not a prerequisite, either.
It rarely includes the equation-based model of computation
that informs this presentation and that can
help level the playing ground between people
with programming experience and those without it.

The required learning is far from easy.
Successful students will have to do a lot of hard thinking
to work their way through a few dozen of the exercises,
and they will surely need to do a few dozen exercises to grasp the concepts.
Reading alone won't be enough.
Well over 150 exercises in the text afford students with plenty of opportunities
for problem solving.
Fortunately, the work pays off, both in terms of immediate satisfaction
and in the long term, if the testimonies of former students are a
reliable measure.
We hope readers will take some pleasure in working their way through
the book, and that they will find what they learn
edifying as they go on to other projects.
\\
\\
\emph{Santa Cruz, California}   \hfill Rex Page \\
\emph{Laramie, Wyoming}         \hfill Ruben Gamboa \\
\emph{January 2018}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
