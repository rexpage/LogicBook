(include-book "numerals")

(defun and-gate (x y) (if (and (= x 1) (= y 1)) 1 0))
(defun or-gate (x y) (if (or (= x 1) (= y 1)) 1 0)) 
(defun xor-gate (x y) (if (= x y) 0 1))
(defun half-adder (x y) (list (xor-gate x y) (and-gate x y)))
(defun full-adder (c-in x y)
  (let* ((h1 (half-adder x y))
         (s1 (first h1))
         (c1 (second h1))
         (h2 (half-adder s1 c-in))
         (s  (first h2))
         (c2 (second h2))
         (c  (or-gate c1 c2)))
    (list s c)))
(defun chk-combo (n)
  (let* ((bit-combo (twos 3 n))
         (c-in (first bit-combo))
         (x    (second bit-combo))
         (y    (third bit-combo)))
    (equal (twos 2 (+ c-in x y))
           (full-adder c-in x y))))
(defconst *chk-full-adder* ; true iff full-adder model is correct
  (and (chk-combo 0) (chk-combo 1) (chk-combo 2) (chk-combo 3)
       (chk-combo 4) (chk-combo 5) (chk-combo 6) (chk-combo 7)))

(defun adder2 (c0 x y)
  (let* ((x0 (first x))
         (x1 (second x))
         (y0 (first y))
         (y1 (second y))
         (b0 (full-adder c0 x0 y0))
         (s0 (first b0))
         (c1 (second b0))
         (b1 (full-adder c1 x1 y1))
         (s1 (first b1))
         (c2 (second b1)))
    (list (list s0 s1) c2)))
(defun adder (c0 x y)
  (if (consp x)
      (let* ((x0 (first x))
             (y0 (first y))
             (b0 (full-adder c0 x0 y0))
             (s0 (first b0))
             (c1 (second b0))
             (bs (adder c1 (rest x) (rest y)))
             (ss (first bs))
             (c  (second bs)))
        (list (cons s0 ss) c))
      (list nil c0)))
