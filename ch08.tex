\chapter{Multiplexers and Demultiplexers}
\label{ch:mux-dmx}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:

\section{Multiplexer}
\label{sec:mux}

Suppose you want to take two lists and shuffle them into one.
You're looking for a perfect shuffle, an element from one list,
then one from the other list, back to the first list, and so on.
This is sometimes called ``multiplexing.''

The term comes from the realm of signal transmission.
There are many more signals than channels to send them on.
One way to share a channel between two signals is to
send a small part of one signal, then part of the other,
then part of the first one again, and so on.
It could be any number signals sharing the channel, not just two,
but the same kind of round-robin approach would work for any
number of signals.
Multiplexing.

We call the operator ``mux''.
It conforms to the pattern suggested by the following equation.

\hspace{1cm} (mux [$x_1$ $x_2$ $x_3$ $\dots$] [$y_1$ $y_2$ $y_3$ $\dots$]) =
     [$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $\dots$] \hfill \{\emph{mux}\}

As usual we want to define the mux operator in terms of
a collection of comprehensive, consistent, and computational equations
that it would have to satisfy if it worked properly
(Figure~\ref{fig:inductive-def-keys}, page \pageref{fig:inductive-def-keys}).
If both lists are non-empty,
then the first element of the multiplexed list is the first element of the first list,
and the second element of the multiplexed list is the first element of the other list.
So, the following formula would
get the first two elements of the multiplexed list right.

\hspace{1cm} (mux (cons $x$ $xs$) (cons $y$ $ys$)) =
(cons $x$ (cons $y$ $\dots$ \emph{rest of formula goes here} $\dots$))

Fortunately, there is no great mystery concerning the missing part of the formula.
Multiplexing what's left of the two input lists will get all the elements
in the right place for the perfect shuffle that the mux operator is supposed to deliver.

That gives us an equation that the mux operator
would have to satisfy if it worked properly.

\hspace{1cm} (mux (cons $x$ $xs$) (cons $y$ $ys$)) = (cons $x$ (cons $y$ (mux $xs$ $ys$)))
\hfill \{\emph{mux11}\}

The \{mux11\} equation covers the case when both lists are non-empty.
It's an inductive equation, so we need to be careful to make sure
that operands of mux on the right-hand-side of the equation
are closer to those in a non-inductive equation than they are
to the operands on the left-hand side.
If not, the equation will fail to be computational, and
we won't be able to use it to define the operator.
We observe that the operands in the invocation on the
right are shorter lists than the operands on the left.
Only  element shorter, but that's enough.

Therefore, the equation \{\emph{mux11}\} can be used
as a defining axiom. It applies whenever both lists are non-empty.
If both lists are empty, there is nothing to multiplex,
so mux would deliver the empty list in that case, but
what should it deliver if one list is empty, but the other isn't?

There are several reasonable choices, and each of them produces
a different operator. One choice is to incorporate the elements
in the non-empty list, just as they are, into the
multiplexed list that the mux operator delivers..
That would make mux satisfy the following equations.

\begin{center}
Axioms for mux Operator
\begin{tabular}{ll}
(mux nil $ys$) = $ys$  & \{\emph{mux0x}\}     \\
(mux $xs$ nil) = $xs$  & \{\emph{mux0y}\}     \\
(mux (cons $x$ $xs$) (cons $y$ $ys$)) = (cons $x$ (cons $y$ (mux $xs$ $ys$))) & \{\emph{mux11}\} \\
\end{tabular}
\end{center}

\label{def:mux}
The three equations, \{\emph{mux0x}\}, \{\emph{mux0y}\}, and \{\emph{mux11}\},
are comprehensive (either both operands are non-empty
or at least one of them is) and computational
(inductive invocations have operands closer to operands in non-inductive equations).
They are consistent because the only overlapping case
occurs when both lists are empty, and in that case,
the overlapping equations
(\{mux0x\} and \{mux0y\}) specify the same result
(namely, the empty list).
We can, therefore, take the equations as axioms
defining the mux operator.

Converting the axioms to ACL2 notation leads to the following
definition.

\label{mux-defun}
\begin{Verbatim}
(defun mux (xs ys)
  (if (not (consp xs))
      ys                                             ; mux0x
      (if (not (consp ys))
          xs                                         ; mux0y
          (cons (first xs)
                (cons (first ys)
                      (mux (rest xs) (rest ys))))))) ; mux11
\end{Verbatim}

\begin{aside}
The multiplexer operator can be defined with two equations instead of three
by swapping the operands in the inductive equation.
When the first operand is non-empty, mux must satisfy the following equation.
\begin{quote}
(mux (cons $x$ $xs$) $ys$) = (cons $x$ (mux $ys$ $xs$))) ~~ \{mux1y\}
\end{quote}

The inductive invocation (mux $ys$ $xs$)
on the right-hand-side of the equation \{mux1y\}
delivers a perfect shuffle of the lists,
starting with the $ys$ list.
So, the formula on the right hand side is a list that starts with $x$,
then alternates between elements of $ys$ and $xs$, which is exactly what
mux should deliver. This leads to a two-equation definition of the mux operator.
The axiom \{mux0x\} from the three-equation definition
(page \pageref{def:mux})
covers the case when the first operand is empty.

These two equations form a definition of the mux operator
that delivers the same results as the three-equation definition.
However, the two-equation definition makes reasoning more complicated
because the operands switch roles in the inductive invocation.
The following defun uses a ``declare'' directive to suggest
an induction scheme to help ACL2 admit
the the two-equation definition to its mechanized logic.

\label{mux-2eq-defun}
\begin{Verbatim}
(defun mux2 (xs ys)       ; declare induction scheme
   (declare (xargs :measure (+ (len xs) (len ys))))
   (if (consp xs)
       (cons (first xs) (mux2 ys (rest xs))) ; mux2-1y
       ys))                                  ; mux2-0x
\end{Verbatim}

\caption{Defining mux with Two Equations}
\label{aside:mux-2eq}
\end{aside}

As always, the axioms that define an operator
determine not only the properties they specify
but also determine all of the other properties of the operator.
What properties would we expect the mux operator to have?
Surely, the number of elements in the multiplexed list
would be the sum of the lengths of it operands.
The following theorem states this property formally,
and ACL2 succeeds in finding a proof by induction.

\label{mux-length-thm}
\begin{Verbatim}
(defthm mux-length-thm
  (= (len (mux xs ys))
     (+ (len xs) (len ys))))
\end{Verbatim}

For practice, let's construct a pencil-and-paper proof of the theorem.
Our strategy will be an induction on the length of the first operand.
We are trying to prove that the following equation holds for all natural numbers, $n$.
\begin{quote}
Theorem \{mux-length\}. $\forall n.$L($n$)\\
L($n$) $\equiv$ (len(mux [$x_1$ $x_2$ $\dots$ $x_n$] $ys$)) = $n$ + (len $ys$) \\
\end{quote}

In the base case, the first operand is empty.
\begin{quote}
Base case: L($0$) $\equiv$ ((len(mux nil $ys$)) = 0 + (len $ys$))
\end{quote}
\begin{center}
\begin{tabular}{lll}
     & (len(mux nil $ys$))    &                 \\
 $=$ & (len $ys$)             & \{\emph{mux0x}\}\\
 $=$ & 0 + (len $ys$)         & \emph{algebra}  \\
\end{tabular}
\end{center}

In the inductive case, the first operand has $n+1$ elements.
\begin{quote}
\label{mux-length-thm-induc-case}
Inductive case: L($n+1$) $\equiv$ (len(mux [$x_1$ $x_2$ $\dots$ $x_{n+1}$] $ys$)) = $(n+1)$ + (len $ys$)
\end{quote}

We split the inductive case, $L(n+1)$, into two parts.
The second operand of mux is either nil or it's not.
We derive the conclusion from both possibilities and cite the \{$\vee$ elimination\}
inference rule (page \pageref{fig-02-deduction-rules})
to conclude that $L(n+1)$ holds.

The proof of the inductive case when $ys$ is nil
is like the proof when $xs$ is nil,
except that it cites \{\emph{mux0y}\} instead of \{\emph{mux0x}\}.
Figure~\ref{fig:prf-mux-len-induc} (page \pageref{fig:prf-mux-len-induc})
presents a proof  of the inductive case when the second operand is non-empty.
That is when the second operand has the form (cons $y$ $ys$)
and the first operand has $n+1$ elements.
This completes the proof, by mathematical induction, of
theorem \{mux-length\}: $\forall n.$L($n$).

\begin{figure}
\begin{quote}
\emph{Proof of} L($n$) $\rightarrow$ L($n+1$) \emph{when both operands of mux are non-empty}\\
L($n+1$) $\equiv$ (len(mux [$x_1$ $x_2$ $\dots$ $x_{n+1}$] (cons $y$ $ys$))) = $(n+1)$ + (len (cons $y$ $ys$))
\end{quote}
\begin{center}
\begin{tabular}{lll}
    & (len(mux [$x_1$ $x_2$ $\dots$ $x_{n+1}$] (cons $y$ $ys$)))             &   \\
$=$ & (len(mux (cons $x_1$ [$x_2$ $\dots$ $x_{n+1}$] (cons $y$ $ys$))))      & \{\emph{cons}\} \emph{(page \pageref{first-rest-cons})} \\
$=$ & (len(cons $x$ (cons $y$ (mux [$x_2$ $\dots$ $x_{n+1}$] (cons $ys$))))) & \emph{algebra} \\
$=$ & 1 + (1 + (len(mux [$x_2$ $\dots$ $x_{n+1}$] (cons $ys$))))             & \{\emph{len1}\} \emph{twice (page \pageref{len-equations})} \\
$=$ & 1 + (1 + ($n$ + (len(cons $ys$))))                                     & \{\emph{L(n)}\} \emph{induction hypothesis} \\
$=$ & ($n$ + 1) + (1 + (len(cons $ys$)))                                     & \emph{algebra} \\
$=$ & ($n$ + 1) + (len(cons $y$ $ys$))                                       & \{\emph{len1}\} \\
\end{tabular}
\end{center}
\caption{Proof of Inductive Case, Theorem \{mux-length\}}
\label{fig:prf-mux-len-induc}
\end{figure}

The next section discusses an operator that goes in the other direction.
It ``demultiplexes'' a list into two lists, reversing the perfect shuffle.
We will prove that the two operators invert each other.

\begin{ExerciseList}
\Exercise
Our proof of the inductive case, L($n+1$), of the mux-length theorem
(page \pageref{mux-length-thm-induc-case})
glossed over the part when the second operand is empty.
Complete that part of the proof. That is, prove the following equation.

\hspace{1cm} (len(mux [$x_1$ $x_2$ $\dots$ $x_{n+1}$] nil)) = $(n+1)$ + (len nil)

\Exercise [label={ex:mul-val-thm}]
Prove that the mux operator neither adds nor loses values from its operands.
That is, a value that occurs in either $xs$ or $ys$ also occurs in (mux $xs$ $ys$)
and, vice versa, a value that occurs in (mux $xs$ $ys$) also occurs in either $xs$ or $ys$.
We will call this the ``mux-val'' theorem:

\begin{quote}
\label{thm:mux-val}
Theorem \{mux-val\}.\\
((occurs-in $v$ $xs$) $\vee$ (occurs-in $v$ $ys$)) $\leftrightarrow$ (occurs-in $v$ (mux $xs$ $ys$))
\end{quote}

\label{def:equivalence-op}
The ``$\leftrightarrow$'' operator in the formula is Boolean equivalence.
The formula $p \leftrightarrow q$ is true if both $p$ and $q$ are true
or if both $p$ and $q$ are false. It is false if one of the two is true
and the other is false. Boolean equivalence means that implication goes both ways:
$p \leftrightarrow q$ = $((p \rightarrow q) \wedge (q \rightarrow p))$.

The ``occurs-in'' predicate is defined as follows.
\begin{quote}
\label{def:occurs-in}
(occurs-in $v$ $xs$) = (consp $xs$) $\wedge$ (($v$ = (first $xs$)) $\vee$ (occurs-in $v$ (rest $xs$))) ~~ \{\emph{occurs-in}\}
\end{quote}

\emph{Hint:} The inductive case of your proof
(that is, the case when $xs$ is non-empty)
can cite the \{$\vee$ elimination\} inference rule,
as in the proof of the mux-length theorem (page \pageref{mux-length-thm}).
The proof of the inductive case will have two parts.
In one part, the value $v$ will be equal to
the first element of $xs$:
$v$ = (first $xs$).
In the other part, $v$ will occur in (rest $xs$).
That is, (occurs-in $v$ (rest $xs$)) will be true.
Prove both parts, separately.
Since they have the same conclusion,
\{$\vee$ elimination\} confirms that the conclusion is true.

\Exercise
\label{mux2-eq-mux}
Do a paper-and-pencil proof that
(mux2 $xs$ $ys$) is the same as (mux $xs$ $ys$).\\
\emph{Note}: mux2 is defined in
Aside~\ref{aside:mux-2eq}, page \pageref{aside:mux-2eq}),
and mux is defined on page \pageref{mux-defun}.

\Exercise
Formalize the theorem of exercise~\ref{mux2-eq-mux} in ACL2.

\end{ExerciseList}

\begin{aside}
In Exercise \ref{ex:mul-val-thm}, the mux-val theorem,
and the axioms for the occurs-in predicate
have been stated in the form we use for pencil-and-paper proofs.
These proofs are rigorous, but not formal
in the sense of the mechanized proofs of ACL2.

Below is an ACL2 formalization of these ideas,
which the ACL2 system succeeds in admitting.
\label{acl2:iff}
The IFF operator is Boolean equivalence
(exercise \ref{ex:mul-val-thm}, page \pageref{def:equivalence-op}).
\\

\label{defun:occurs-in}
\begin{Verbatim}
(defun occurs-in (x xs)
  (if (consp xs)
      (or (equal x (first xs))
          (occurs-in x (rest xs)))
      nil))
(defthm mux-val-thm
  (iff (occurs-in v (mux xs ys))
       (or (occurs-in v xs)
           (occurs-in v ys))))
\end{Verbatim}
\label{defthm:mux-val}

\caption{Formal Version of Mux-Val Theorem}
\label{aside:mux-val-thm}
\end{aside}


\section{Demultiplexer}
\label{sec:dmx}

A demultiplexer transforms a list of signals that alternate between
$x$-values and $y$-values into two lists,
with the $x$-values in one list and $y$-values in the other.

\hspace{1cm} (dmx [$x_1$ $y_1$ $x_2$ $y_2$ $x_3$ $y_3$ $\dots$]) =
[[$x_1$ $x_2$ $x_3$ $\dots$] [$y_1$ $y_2$ $y_3$ $\dots$]]
\hfill \{\emph{dmx}\}

The following equations form an inductive definition of dmx.
The inductive equation covers the case when
the operand has at least two elements
(that is, it starts with an $x$ and then a $y$),
and the non-inductive equations cover the cases
when the operand has just one element or none.
\begin{center}
Axioms for dmx
\begin{tabular}{ll}
(dmx [$x_1$ $y_1$ $x_2$ $y_2$ $\dots$ $x_{n+1}$ $\dots$]) $=$ [(cons $x_1$ $xs$) (cons $y_1$ $ys$) &\{\emph{dmx2}\} \\
~~~~~~where [$xs$ $ys$] $=$ (dmx $x_2$ $y_2$ $\dots$ $x_{n+1}$ $\dots$])                           &\\
(dmx [$x1$]) =  [[$x_1$] nil]                                                                      &\{\emph{dmx1}\} \\
(dmx nil) $=$ [nil ~ nil]                                                                          &\{\emph{dmx0}\} \\
\end{tabular}
\end{center}

The informal axioms for dmx provide a basis for a formal definition.
The formal version takes advantage of the fact that if the operand
has less than two elements, then it is the first component of the result,
and the second component is the empty list.

\label{dmx-defun}
\begin{Verbatim}
(defun dmx (xys)
  (if (consp (rest xys))      ; 2 or more elements?
      (let* ((x (first xys))
             (y (second xys))
             (xsys (dmx (rest (rest xys))))
             (xs (first xsys))
             (ys (second xsys)))
        (list (cons x xs) (cons y ys)))      ; dmx2
      (list xys nil)))  ; 1 element or none  ; dmx1
\end{Verbatim}

\begin{aside}
A more clever definition of the demultiplexer
observes that if the operand alternates between $x$ and $y$ values,
starting with an $x$,
then the same list without is first element alternates similarly
starting with a $y$. The definition is shorter,
but makes reasoning more complicated.\\
\begin{center}
Axioms for dmx2 (maybe too clever by half)
\begin{tabular}{ll}
(dmx2 [$x_1$ $y_1$ $x_2$ $y_2$ $\dots$]) $=$ [(cons $x_1$ $xs$) $ys$]  & \{\emph{dmx2-1x}\} \\
~~~~~~where [$ys$ $xs$] $=$ (dmx2 [$y1$ $x_2$ $y_2$ $\dots$])          & \\
(dmx2 nil) $=$ [nil ~ nil]                                             & \{\emph{dmx2-0x}\} \\
\end{tabular}
\end{center}
\caption{Cleverness Sometimes Complicates Reasoning}
\label{aside:dmx-defun-trick}
\end{aside}

Like the the multiplexer,
the demultiplexer preserves the total length
and preserves the values in its operand.
ACL2 succeeds in verifying these facts without assistance,
and the pencil-and-paper proofs are similar to the corresponding
theorems for the multiplexer.

The two operators also satisfy some round-trip properties
that bolster or confidence that they do what we expect them to do.
Demultiplexing a list of $x$-$y$ values into the list of
$x$-values and the list of $y$-values, then multiplexing
those two lists, reproduces the original list of $x$-$y$ values.
It works the other way around, too, if the operands of
the mux operator are lists of the same length.\footnote{Both
of the round-trip properties require the operands to be
true lists because the multiplexer can lose information
if its operands aren't true lists.}

\label{thm:mux-inverts-dmx}
\label{thm:dmx-inverts-mux}
\begin{Verbatim}
(defthm mux-inverts-dmx-thm
  (implies (true-listp xys)
           (equal (mux (first  (dmx xys))
                       (second (dmx xys)))
                  xys)))
(defthm dmx-inverts-mux-thm
  (implies (and (true-listp xs) (true-listp ys)
                (= (len xs) (len ys)))
           (equal (dmx (mux xs ys))
                  (list xs ys))))
\end{Verbatim}

The dmx operator delivers every other element of the operand in
one component and the remaining elements in the other component.
That means that each component of the result is half a long as the operand.
If the operand has an odd number of elements, the extra one goes into the first component.
These length properties can be specified in terms of the floor and ceiling
operators (Aside~\ref{floor-ceiling-ops-brackets}, page \pageref{floor-ceiling-ops-brackets}).
The length of the first component is the length of the operand divided by two
and rounded up to the next integer if the operand has an odd number of elements.
The second component is also half the length of the operand, but rounded down if necessary.
The mechanized logic of ACL2 succeeds in proving these theorems,
but it needs the help of some theorems about arithmetic.

\label{thm:dmx-length-first-second}
\begin{Verbatim}
(include-book "arithmetic-3/top" :dir :system)
(defthm dmx-len-first
   (= (len (first (dmx xs)))
      (ceiling (len xs) 2)))
(defthm dmx-len-second
   (= (len (second (dmx xs)))
      (floor (len xs) 2)))
\end{Verbatim}

\begin{ExerciseList}
\Exercise
Prove that the dmx operator preserves total length.
That is, prove the theorem
stated formally in ACL2 as follows.

\label{thm:dmx-length}
\begin{Verbatim}
(defthm dmx-length-thm
  (= (len xys)
     (+ (len (first (dmx xys)))
        (len (second (dmx xys))))))
\end{Verbatim}

\Exercise
Do paper and pencil proofs of the dmx-len-first and dmx-len-second
theorems (\pageref{thm:dmx-length-first-second}).
You may find the proofs easier if you split them into
two cases, one when the number of elements in the operand is even
(that is, $2n$, for some natural number $n$),
the other when the number of elements is odd ($2n+1$).

\Exercise [label={ex:dmx-val-thm}]
State formally, in ACL2, the ``dmx-val'' theorem
analogous to the mux-val theorem (page \pageref{defthm:mux-val}).

\Exercise
The dmx-val theorem (Exercise \ref{ex:dmx-val-thm})
says that dmx neither adds nor drops values from its operand.
Do a paper-and-pencil proof of the dmx-val theorem.

\Exercise
Do a pencil-and-paper proof of the mux-inverts-dmx theorem
(page \pageref{thm:mux-inverts-dmx}).

\Exercise
Do a pencil-and-paper proof of the dmx-inverts-mux theorem
(page \pageref{thm:dmx-inverts-mux}).

\Exercise
\label{dmx2-eq-dmx}
Do a paper-and-pencil proof that
(dmx2 $xs$) is the same as (dmx $xs$).\\
\emph{Note}: dmx2 is defined in Aside~\ref{aside:dmx-defun-trick}, page \pageref{aside:dmx-defun-trick},
and dmx is defined on page \pageref{dmx-defun}.

\end{ExerciseList}
