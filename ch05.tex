\chapter{Binary Numerals}
\label{ch:binary-numerals}
\section{Numbers and Numerals}
\label{sec:numbers-numerals}
Numbers are mathematical objects with certain properties,
and they come with operators, such as addition
and multiplication, that produce new numbers from numeric
operands.
Because numbers are mathematical objects, they are ephemeral.
You can't really get your hands on them.
They are figments of the imagination.

However, numbers are useful and to deal with them,
we need to be able to write them down.
Decimal numerals are one way to do this.
The \index{numeral!decimal}numeral 144 stands for the number
of eggs in a dozen cartons of eggs.
The numeral 1215 stands for the number of
years between the twenty-seventh year of the reign
of Caesar Augustus and the signing of the Magna Carta.

However, ``144'' and ``1215'' are \index{numeral!vs number}numerals.
They are not numbers. They are symbols that stand for numbers,
and they are not the only symbols in use for that purpose.
The symbols CXLIV and MCCXV (Roman \index{numeral!Roman}numerals) stand for the same two numbers.
So do the symbols $90_{16}$ and $4BF_{16}$ (hexadecimal \index{numeral!hexadecimal}numerals).
The symbols 144 and 1215 are decimal numerals,
which is the representation most
people turn to when they do arithmetic.

The decimal representation is, in fact, so embedded in
our experience and practice that we often confuse
the symbol with the number.
In fact, the dictionary lists ``number'' and ``numeral'' as synonyms.
Usually, there is no harm in considering them to be the same thing,
but we are going to use numerals
to do arithmetic in a mechanized way, and we will
be careful to separate numbers as mathematical
objects from the symbols that represent them.
We will refer to the mathematical object as a \index{number!vs numeral}number
and to the symbol representing it as a \index{numeral!vs number}numeral.

Let's think about how we interpret a decimal numeral as a number.
Take the \index{numeral!decimal}numeral 1215, for example.
Each digit in the numeral has a different interpretation.
The first digit is the number of thousands in the number
that 1215 stands for. The second tells us the number
of hundreds, then the tens, and finally the units.
The following formula is a way to express this interpretation.

\begin{center}
$1 \times 10^3 + 2 \times 10^2 + 1 \times 10^1 + 5 \times 10^0$
\end{center}

This formula computes a number from the individual digits
in the numeral using standard arithmetic operations
(addition, multiplication, and exponentiation).
It shows us what the individual digits in the numeral stand for,
and gives us a leg up on figuring out other kinds of numerals.
The digits in the hexadecimal numeral have a similar meaning,
but with a different base. Decimal numerals are based on
powers of ten, and hexadecimal numerals are based on powers of sixteen.

The system of decimal numerals calls of ten different symbols to represent digits:
0, 1, 2, \dots 9.
The hexadecimal system requires sixteen different symbols, conventionally
0, 1, 2, \dots 9, A, B, C, D, E, F.
The digits stand for the customary numbers
(0 for zero, 2 for two, and so on),
and the letters A through F
stand for the numbers ten through fifteen.\footnote{There
are no conventional squiggles for digits beyond fifteen,
presumably because no numeral system
with a base exceeding sixteen is in common use.
A few thousand years ago, the Mayan civilization used a base twenty system
with nineteen different symbols for digits.
The ancient Sumerians used a system with base sixty,
but with special arrangements to deal with the lack of a symbol for zero.}
That leads to the following
formula to express the meaning of the hexadecimal numeral $4BF_{16}$.
(Remember, B stands for eleven, F for fifteen.)
\begin{center}
$4 \times 16^2 + 11 \times 16^1 + 15 \times 16^0$
\end{center}
Formulas like this
convert numerals to numbers.
No doubt you could construct the appropriate formula
for any given numeral, decimal, hexadecimal, or any base.

\begin{aside}
Perhaps you noticed a subtle confusion in the formulas we use
to explain the meaning of numerals. At first, we claim that
1215 is merely a \index{symbol, for number}symbol standing for a mathematical object.
And, we claim that the digit 2 is merely a symbol standing
for the number of items in a pair, along with similar
claims for the digits 1 and 5. Then, we use those symbols
in the formula $1 \times 10^3 + 2 \times 10^2 + 1 \times 10^1 + 5 \times 10^0$
as if they were numbers.

There is some sleight of hand going on here.
We are trapped by our terminology.
Numbers as mathematical objects are figments of our imagination,
but when we write formulas, we have to choose some symbols to
represent them.
So, in the formula $1 \times 10^3 + 2 \times 10^2 + 1 \times 10^1 + 5 \times 10^0$,
we use the symbols 1, 10, 3, 2, 5, and 0 as if they were numbers.
But, in the numeral 1215, the symbols 1, 2, and 5 are not numbers.
They are symbols standing for numbers.

It's even worse with the hexadecimal numeral $4BF_{16}$
and the formula $4 \times 16^2 + 11 \times 16^1 + 15 \times 16^0$.
In the formula we have rewritten the symbol B as the decimal numeral 11
and the symbol F as the decimal numeral 15.
And, we've had the temerity to pretend that symbols
in the formula are numbers when they are really decimal numerals,
as they were in the formula for the meaning of the decimal numeral 1215.

Furthermore, we've really mixed things up in the numeral
$4BF_{16}$ because the ``4BF'' part is in hexadecimal notation
and the ``16'' part is a decimal numeral indicating that we are
to interpret the digits in base sixteen rather than base ten.
Try to get your head around this.
We're more-or-less stuck with it. Figments of our imagination have
to be materialized, somehow, if we are going to talk about them.
\index{digit}
\caption{Digits as Numbers}
\label{aside-digits-as-numbers}
\end{aside}

We'll say more about to converting numerals to numbers later,
but what about going the other direction, converting
numbers to numerals?
Suppose someone gives you an operator called dgts that
converts a number to a decimal numeral.
Let's say that (dgts 1215) would deliver the sequence [5 1 2 1].
That is, dgts delivers a list of the decimal digits
of its operand, 
\index{representation!decimal numeral}
starting with the ones digit (a 5 in this case),
then the tens digit, and so on, reading right-to-left from
customary way of writing the numeral.
You might try it on a few numbers to see what it does.
\begin{Verbatim}
(check-expect (dgts 1215) '(5 1 2 1))
(check-expect (dgts 1964) '(4 6 9 1))
(check-expect (dgts 12345) '(5 4 3 2 1))
(check-expect (dgts 0) '())
\end{Verbatim}

\begin{aside}
\emph{What! The dgts operator delivers the digits backwards! Why is that?}

Of course
\seeonlyindex{dgts}{operator}\index{operator, by name!dgts (digits from number)}dgts
could have delivered the digits in the
customary order, but reverse order simplifies some of the
equations we will use to interpret numerals.
We will write numerals like 1215 in the usual way, but
the dgts operator delivers them in the form of
a sequence with the digits in reverse order: [5 1 2 1].

\index{representation!decimal numeral}
Besides being backwards, the elements in the sequence are numbers,
not symbolic digits.
That is another part of our sleight of hand.
We are using numbers to represent the digit symbols.
We could convert them to pure symbols,
but leaving them in the form of numbers
simplifies parts of the discussion.

By the way, the sequence notation [5 1 2 1] is the symbol we use
to describe the \index{sequence!for numeral}\index{numeral!seqeuence for}sequence,
but the sequence itself is a mathematical object.
It's another figment of our imagination,
ephemeral in the same sense as a number.
\caption{Numerals as Sequences \dots Backwards}
\label{numeral-as-sequence}
\end{aside}

Wait a minute!
Why does (dgts 0) deliver the empty sequence instead of the one-element sequence [0]?
That's another little trick.
Besides delivering the digits in reverse order, 
\index{representation!decimal numeral}
\index{leading zero}\index{numeral!leading zero}leading zeros are omitted.
We could write the numeral 1964 with as many leading zeros as we like.
The numerals 01964 and 000001964 also stand for the same number.
Those numerals correspond to [4 6 9 1 0] and [4 6 9 1 0 0 0 0 0] in
our list format. ``Leading zeros'' come at the end when the
digits are in reverse order.

However, dgts doesn't include any
 \index{leading zero}\index{numeral!leading zero}leading zeros
in the numerals it delivers.
It leaves them all off, even for the number zero.
That's why (dgts 0) is nil.
The numeral (dgts 012345) is the same as the numeral (dgts 12345), too.
Both of those formulas would deliver the sequence [5 4 3 2 1].
No leading zeros.

The computer interprets the decimal numeral 012345 in the formula (dgts 012345)
as a mathematical object.
What form does that object take? None of your business.
That's the computer's business.
It has it's own way of dealing with numbers.
Later, we'll study the way most computers do this,
but for now we will assume that the computer has some way of turning
numerals into whatever form it uses to represent numbers.

Now that we've run a few sanity checks, we want to do some serious testing.
That means big batches of automated tests on random data.
Coming up with automated tests calls for a little more thought.
Let's start small. How about the last digit in a decimal numeral?
What mathematical formula would deliver the last digit in a
decimal numeral, given an arbitrary, positive integer $n$?

The last digit in a decimal numeral is the remainder when you divide
the number by ten. The formula that converts a numeral to a number
makes that clear.
\begin{center}
$1 \times 10^3 + 2 \times 10^2 + 1 \times 10^1 + 5 \times 10^0$
\end{center}

Each of the terms in the formula is a product of a power
of ten with another number. A power of ten is, of course,
a multiple of ten, so none of the terms contribute to the remainder
when dividing by ten. None of them, that is, except the last one.
It does not have a factor of ten in it because the ten is raised to the
power zero, and $10^0$ is one, which is not a multiple of ten.
So, to get the last digit in the numeral, all we need to do is to
compute the remainder in the division of the number by ten.

\begin{aside}
To get this all straight,
transport yourself back to the third grade.
In those days, when you learned long division,
there were four parts to the problem,
and they all had names.

\begin{tabular}{ll}
\emph{divisor}   & number you divide by \\
\emph{dividend}  & number you divide by the divisor \\
\emph{quotient}  & what you get when you do the division \\
\emph{remainder} & what's left over to make up the difference
\end{tabular}
\begin{center}
\begin{tabular}{ll}
$q$ $=$ (floor $n$ $d$) & \emph{quotient}  \\
$r$ $=$ (mod $n$ $d$)   & \emph{remainder} \\
$n = qd + r$            & \{\emph{check}$\div$\} \\
\end{tabular}
\end{center}
\index{division!third grade}\index{division!long division}\index{division!floor, mod}
\seeonlyindex{long division}{division}
\index{operator, by name!floor (divide, round down)}\seeonlyindex{mod}{operator}\index{operator, by name!mod (remainder)}
\caption{mod and floor: Think Third-Grade Division}
\label{third-grade-division}
\end{aside}

The remainder is
what the mod operator delivers (page \pageref{mod-function}).
The following formula uses mod to make sure the last digit in the numeral
that the dgts operator delivers for the number $n$ is correct.
\begin{Verbatim}
(= (first (dgts n)) (mod n 10))
\end{Verbatim}

Since dgts delivers the digits backwards,
(first (dgts $n$)), the first digit in the sequence,
is the units digit in the numeral, which is the last digit
when the numeral is written in the conventional format.
The formula checks to make sure that
the units digit of the numeral that dgts delivers is (mod $n$ 10),
the remainder when dividing $n$ by 10.

We can use the doublecheck facility of Proof Pad to run this test on a batch of random numbers.
We need to be careful not to allow zero to pop up in the testing
because (dgts 0) is nil, so there is no first digit to check.
Besides, we've already completed the testing of (dgts 0) in our sanity checks.
We can avoid retesting zero by adding one to a random natural number.
That produces a random, non-zero, positive integer.
\begin{Verbatim}
(defproperty dgts-last-digit-tst
  (n-1  :value (random-natural))
  (let* ((n (+ n-1 1))) ; avoid n=0
    (= (first (dgts n))
       (mod n 10))))
\end{Verbatim}

That takes care of testing the units digit, but what about the others?
We can do something about those by observing that the quotient,
when $n$ is divided by ten,
is a number with the same digits as $n$,
except that the last digit is missing.
Remember, we're doing third-grade arithmetic here.
The quotient is the main result of the division.
No fraction, no decimal point, no remainder. Just the whole-number quotient.
Since we've already tested to make sure the last digit is correct,
we don't need to worry about that.
We only need to worry about the other digits.
The intrinsic operator ``floor'' (page \pageref{floor-def})
produces the quotient (discarding the remainder).
We can get those other digits by applying dgts to (floor $n$ $10$)

The following formula implements the test we have in mind.
It checks to make sure the digits other than the units digit
in the sequence dgts delivers for $n$
are the same as the digits in the sequence
dgts delivers for the quotient in $(n \div 10)$.
\begin{Verbatim}
(equal (rest (dgts n))       ; all digits except the units digit
       (dgts (floor n 10)))) ; digits of the quotient
\end{Verbatim}

As with the test of the units digit,
we can run a batch of tests based on our rest-of-the-digits
observation by defining a doublecheck property.
\begin{Verbatim}
(defproperty dgts-other-digits-tst
  (n-1  :value (random-natural))
  (let* ((n (+ n-1 1)))          ; avoid n=0
    (equal (rest (dgts n))
           (dgts (floor n 10)))))
\end{Verbatim}

It would be nice to run these tests, but dgts is not an intrinsic operator.
We have to provide a definition for it.
To do that we use the defun command, which is similar to defproperty,
but without any value specifications. The definition will be inductive,
of course, using some ideas we discussed in putting together tests,
and will follow the three C's of Figure~\ref{fig:inductive-def-keys}
(page \pageref{fig:inductive-def-keys}), repeated here and customized for dgts.
\begin{samepage}
\index{three C's}\index{definition!inductive (circular)}
\begin{center}
\begin{tabular}{lp{3.5in}}
\emph{Complete}      & Two cases: the number is zero or it isn't. So, two formulas.\\
\emph{Consistent}    & The cases do not overlap---no chance for inconsistency.\\
\emph{Computational} & Inductive case ($n > 0$): operand is
                       divided by ten, making it closer to zero
                       (the non-inductive case).
\end{tabular}
\end{center}
\end{samepage}

\label{dgts-defun}
\index{operator, by name!dgts (digits from number)}\index{numeral!from number}
\index{representation!decimal numeral}
\begin{Verbatim}
(defun dgts (n)
  (if (zp n)
      nil                          ; {dgts0}
      (cons (mod n 10)
            (dgts (floor n 10))))) ; {dgts1}
\end{Verbatim}

This definition uses the predicate zp (Aside \ref{zp-def}, page \pageref{zp-def})
to detect the value zero within the domain of natural numbers..
If you put the definition of dgts at the beginning of a program
and import the ``testing'' and ``doublecheck" facilities, you
can enter the tests and run them using Proof Pad.
You can also enter formulas in the command panel to compute
decimal numerals for any natural numbers you choose.

\begin{aside}
ACL2 will not admit an operator into its logic unless
it can prove that the operator always delivers a value in
a finite number of computational steps.
This is because operators that don't terminate complicate the reasoning process.
Proving that dgts terminates for all inputs
requires applying some theorems of modular arithmetic.
Fortunately, someone has put together a package of theorems on that topic
in the
\index{book!arithmetic-3/floor-mod} 
``arithmetic-3/floor-mod/floor-mod'' book.
ACL2 will admit the definition of dgts when those theorems
have been imported into its logic world by an include-book directive
(see Exercise \ref{mod-div-defthm}, page \pageref{mod-div-defthm}).
\index{ACL2!admit}\index{admit, ACL2}
\caption{Termination, ACL2 Admit, and floor/mod Equations}
\label{admit-def}
\label{floor-mod-book}
\end{aside}

\begin{ExerciseList}
\Exercise Let $y$ stand for the number of years
between the signing of the Magna Carta and
the signing of the United States Declaration of Independence.
Find the numeral for $y$ and use dgts (page \pageref{dgts-defun})
to verify that you got it right.


\Exercise \label{modular-division}\index{theorem, by name!\{mod-div\}}
\index{division!floor, mod}
Prove \{\emph{mod-div}\}:
(mod (* $a$ $x$) (* $a$ $b$)) = (* $a$ (mod $x$ $b$)) \\
\emph{Hint}: You won't need induction, but the following facts will help.
Suppose $x$ is the dividend, $d$ the divisor, and $q$ the quotient
in a third-grade division problem (page \pageref{third-grade-division}).
Then, $r$ = (mod $x$ $d$) is the remainder (page \pageref{mod-function}).
The standard method of verifying a correct solution to a
third-grade division problem is to verify the equation
$(qd + r) = x$. Furthermore, it is always the case
that $0 \le r < d$. In other words (mod $x$ $d$) is the number $r$
in the range $0 \le r < d$ such that $qd + r = x$.

\Exercise \label{mod-div-defthm}\index{division!floor, mod}
Define the \{\emph{mod-div}\} theorem
in ACL2 notation, and use ACL2 to verify that it is a theorem.
Since the theorem does not hold for all numbers $a$, $b$, and $x$,
you will need to include certain hypotheses in the implication
that you ask ACL2 to prove. If you state it correctly and import
theorems about modular arithmetic contained in the floor-mod book,
ACL2 will succeed.\\

\label{floor-mod-include-book}
\index{book!arithmetic-3/floor-mod}\index{directory (:dir)!:system}
\index{book!directory (:dir)}
\index{directive!include-book}\index{directory (:dir)!:system}\index{system, :dir}
\phantom{x}\hspace{2em}(include-book "arithmetic-3/floor-mod/floor-mod" :dir :system)
\end{ExerciseList}

\section{Numbers from Numerals}
\label{sec:numbers-from-numerals}
The dgts operator (page \pageref{dgts-defun})
provides a way to compute a decimal
numeral, given a number. How about going in the other direction?
Given a decimal numeral, compute the corresponding number.
You already know the formulas.
\begin{samepage}
\begin{center}
\begin{tabular}{rrr}
$1 \times 10^3 + 2 \times 10^2 + 1 \times 10^1 + 5 \times 10^0$ &$=$ & 1215 \\
$1 \times 10^2 + 4 \times 10^1 + 4 \times 10^0$                 &$=$ &  144 \\
\end{tabular}
\end{center}
\end{samepage}

What properties would an operator
converting decimal numerals to numbers have?
Since dgts produces numerals represented as sequences
of decimal digits in the reverse of the usual order
(that is, with the units digit first,
then the tens digit, then hundreds, and so on),
let's assume that numerals will take that form.

We will call the operator that converts decimal numerals to numbers nmb10.
We know that (nmb10 nil) must be zero because (dgts 0) delivers
zero, and we are trying to convert numerals produced by dgts
back the numbers they came from.
How about a one-digit numeral $[x_0]$?
The equation in that case would be (nmb10 [$x_0$]) = $x_0$.

If there are two or more digits, the numeral would take the form
[$x_0$ $x_1$ \dots $x_{n+1}$].
Then, the equation would be
\begin{center}
(nmb10 [$x_0$ $x_1$ $x_2$ \dots $x_{n+1}$]) =
$(x_0 + x_1 \times 10^1 + x_2 \times 10^2 + \dots x_{n+1} \times 10^{n+1})$
\end{center}

Since all of the terms in the sum
include a factor of ten, except the first term,
we can factor ten out of all of the terms beyond the first.
Factoring the formula in this way produces a new equation.
\begin{center}
(nmb10 [$x_0$ $x_1$ $x_2$ \dots $x_{n+1}$]) = $(x_0 + 10 \times (x_1 \times 10^0 + x_2 \times 10^1 + \dots x_n \times 10^n))$
\end{center}

But, the sequence [$x_1$ $x_2$ \dots $x_{n+1}$] is also a decimal numeral,
albeit for a different number.
The number it denotes is
$(x_1 \times 10^0 + x_2 \times 10^1 + \dots x_n \times 10^n)$,
which is the value nmb10 should deliver, given the numeral [$x_1$ $x_2$ \dots $x_{n+1}$].
\begin{center}
(nmb10 [$x_1$ $x_2$ \dots $x_{n+1}$]) = $(x_1 + x_2 \times 10^1 + \dots x_{n+1} \times 10^n)$
\end{center}

Observe that this formula for (nmb10 [$x_1$ $x_2$ \dots $x_{n+1}$]) is identical
to the part of the formula in the previous equation that is multiplied by ten.
Therefore, we can rewrite that equation as follows.
\begin{center}
(nmb10 [$x_0$ $x_1$ $x_2$ \dots $x_{n+1}$]) = $(x_0 + 10 \times$ (nmb10 [$x_1$ $x_2$ \dots $x_{n+1}$])$)$
\end{center}

This is an inductive equation that delivers the right value for
numerals with two or more digits. It also works
for one-digit numerals because (nmb10 nil) is zero:
(nmb10 [$x_0$]) = $(x_0 + 10 \times$ (nmb10 nil)$) = (x_0 + 10 \times 0) = x_0$.

Together, the equation for numerals with one or more digits
and the equation for empty numerals conform to the
rule of the three C's
(page \pageref{fig:inductive-def-keys}),
so we have the makings of an inductive definition of nmb10.
The following equations summarize our analysis and show how
the first and rest operators
(page \pageref{first-rest-cons}) can be used
to extract the digits of the numeral.
From that point, constructing the ACL2
is a straightforward translation of the equations to prefix notation.

\seeonlyindex{nmb10}{operator}\index{number!from numeral}
\begin{center}
\begin{tabular}{rlll}
(nmb10 [$x_0$ $x_1$ $x_2$ \dots $x_{n+1}$]) & $=$ &$(x_0 + 10 \times$ (nmb10 [$x_1$ $x_2$ \dots $x_{n+1}$])$)$ &\emph{\{n10.1\}}\\
(nmb10 nil)                           & $=$ &$0$   &\emph{\{n10.0\}}\\
$x_0$                         & $=$ &(first [$x_0$ $x_1$ $\dots$ $x_n$]) &\\
{[$x_1$ $\dots$ $x_n$]}       & $=$ &(rest  [$x_0$ $x_1$ $\dots$ $x_n$]) &\\ % mysterious error without curly braces {[ ... ]}, something to do with an optional parameter after
\end{tabular}
\end{center}

\label{nmb10-defun}\index{operator, by name!nmb10 (number from digits)}
\begin{Verbatim}
(defun nmb10 (xs)
  (if (consp xs)
      (+ (first xs)               ; {n10.1}
         (* 10 (nmb10 (rest xs))))
      0))                         ; {n10.0}
\end{Verbatim}

We have derived this definition carefully,
from things we know about numbers,
but we can use logic to be sure we got it right.
We want to prove that
(nmb10 [$x_0$ $x_1$ \dots $x_{n}$])
delivers the same number as the formula
$(x_0 + x_1 \times 10^1 + x_2 \times 10^2 + \dots x_{n} \times 10^{n})$.
\begin{samepage}
\label{horner10-thm}
\index{theorem!Horner}
\index{theorem, by name!\{Horner 10\}}
\begin{center}
Theorem \{\emph{Horner 10}\} \\
(nmb10 [$x_0$ $x_1$ \dots $x_{n}$]) =
$x_0 + x_1 \times 10^1 + x_2 \times 10^2 + \dots x_{n} \times 10^{n}$
\end{center}
\end{samepage}

Theorem \{\emph{Horner 10}\} states that the operator nmb10
computes a sum of multiples of successive powers of ten.
The multipliers (known as ``coefficients'') of the powers
of ten are the digits in a decimal numeral.
We call it the theorem \emph{Horner 10} because
the scheme it uses to carry out the computation is
known as Horner's rule.
Proving Theorem \{\emph{Horner 10}\} amounts to
verifying that $(\forall n.H(n))$ is true,
where the predicate $P$ is defined on the natural numbers,
its universe of discourse, as follows.
\begin{center}
$H(n) \equiv$
((nmb10 [$x_0$ $x_1$ \dots $x_{n}$]) =
$(x_0 + x_1 \times 10^1 + x_2 \times 10^2 + \dots x_{n} \times 10^{n}))$
\end{center}

The proof will use mathematical induction.
We begin by proving he base case, $H(0)$.
\begin{center}
\begin{tabular}{lll}
    & $H(0) \equiv$ ((nmb10 [$x_0$]) = $x_0$) & \\
\hline
    & (nmb10 [$x_0$])           & \\
$=$ & (nmb10 (cons $x_0$ nil))  & \{\emph{cons}\} \emph{(page \pageref{first-rest-cons})} \\
$=$ & (+ (first (cons $x_0$ nil)) ($*$ 10 (nmb10 (rest (cons $x_0$ nil)))))  & \{\emph{n10.1}\} \emph{(nmb10, page \pageref{nmb10-defun})} \\
$=$ & (+ $x_0$ ($*$ 10 (nmb10 (rest (cons $x_0$ nil)))))  & \{\emph{first}\} \emph{(page \pageref{first-rest-cons})} \\
$=$ & (+ $x_0$ ($*$ 10 (nmb10 nil)))  & \{\emph{rest}\} \emph{(page \pageref{first-rest-cons})} \\
$=$ & (+ $x_0$ ($*$ 10 0))  & \{\emph{n10.0}\} \emph{(nmb10, page \pageref{nmb10-defun})} \\
$=$ & $x_0$  & \{\emph{algebra}\} \\
\end{tabular}
\end{center}

Now, we turn to the inductive case, $\forall n. (H(n) \rightarrow H(n+1))$.
As usual, we derive $H(n+1)$ assuming that the induction hypothesis $H(n)$ is true
and conclude that $\forall n.H(n)$ is true,
citing mathematical induction
(Figure~\ref{induction-rule}, page \pageref{induction-rule}).

\begin{center}
\begin{tabular}{lll}
 & $H(n+1) \equiv$
((nmb10 [$x_0$ $x_1$ \dots $x_{n+1}$]) =
$(x_0 + x_1 \times 10^1 +  \dots x_{n+1} \times 10^{n+1}))$ & \\
\hline
    & (nmb10 [$x_0$ $x_1$ \dots $x_{n+1}$])           & \\
$=$ & (nmb10 (cons $x_0$ [$x_1$ \dots $x_{n+1}$]))  & \{\emph{cons}\}\\
$=$ & (+ (first (cons $x_0$ [$x_1$ \dots $x_{n+1}$])) ($*$ 10 (nmb10 (rest (cons $x_0$ [$x_1$ \dots $x_{n+1}$])))))  & \{\emph{n10.1}\} \\
$=$ & (+ $x_0$ ($*$ 10 (nmb10 (rest (cons $x_0$ [$x_1$ \dots $x_{n+1}$])))))  & \{\emph{first}\} \\
$=$ & (+ $x_0$ ($*$ 10 (nmb10 [$x_1$ \dots $x_{n+1}$])))  & \{\emph{rest}\}\\
$=$ & (+ $x_0$ ($*$ 10 $(x_1 + x_2 \times 10^1 + \dots x_{n+1} \times 10^{n})))$  & \{$H(n)$\}\\
$=$ & $(x_0 + x_1 \times 10^1 + x_2 \times 10^2 + \dots x_{n+1} \times 10^{n+1})$  & \{\emph{algebra}\} \\
\end{tabular}
\end{center}

Theorem \{\emph{Horner 10}\} confirms that nmb10 delivers the
number that its operand, which is a base 10 numeral, denotes.
We would also like to know that the dgts operator
produces the correct numeral.
Since we know that nmb10 correctly interprets base 10 numerals,
we can verify that (dgts $n$) produces the base 10 numeral for $n$
by proving the following theorem.
\begin{center}
\label{dgts-ok}\index{theorem, by name!\{dgts-ok\}}
\index{number!from digits}
Theorem \{\emph{dgts-ok}\}:
(nmb10 (dgts $n$)) = $n$
\end{center}

In other words, we want to prove that
$(\forall n.D(n))$ is true, where D($n$) stands the following proposition.
\begin{center}
$D(n) \equiv$ ((nmb10 (dgts $n$)) $=$ $n$)
\end{center}

The universe of discourse
for the predicate $D$ is the natural numbers,
so we can try to use mathematical induction
to prove that $(\forall n.D(n))$ is true.
That requires a proof of $D(0)$ and
a proof of $(\forall n.(D(n) \rightarrow D(n+1)))$.

\begin{center}
\begin{tabular}{lll}
    & $D(0) \equiv$ ((nmb10 (dgts $0$)) = $0$) & \\
    \hline
    & (nmb10 (dgts $0$)) & \\
$=$ & (nmb10 nil)        & \{\emph{dgts0}\} (page \pageref{dgts-defun}) \\
$=$ & 0                  & \{\emph{n10.0}\} (page \pageref{nmb10-defun}) \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{lll}
    & $D(n+1) \equiv$ ((nmb10 (dgts (+ $n$ 1))) = (+ $n$ 1)) & \\
    \hline
    & (nmb10 (dgts (+ $n$ 1)))           & \\
$=$ & (nmb10 (cons (mod (+ $n$ 1) 10) (dgts (floor (+ $n$ 1) 10)))  & \{\emph{dgts1}\} (page \pageref{dgts-defun})\\
$=$ & (+ (mod (+ $n$ 1) 10) ($*$ 10 (nmb10 (dgts (floor (+ $n$ 1) 10)))))  & \{\emph{n10.1}\} (page \pageref{nmb10-defun})\\
$=$ & (+ (mod (+ $n$ 1) 10) ($*$ 10 (floor (+ $n$ 1) 10)))  & \{$D$(floor (+ $n$ 1) 10)\} \\
$=$ & (+ $n$ 1)  & \{\emph{check}$\div$\} (page \pageref{third-grade-division})
\end{tabular}
\end{center}

If you were paying very close attention,
you may have noticed that we our proof of $D(n) \rightarrow D(n+1)$
was not according to Hoyle.
To prove this implication, we need to prove that $D(n+1)$ is true whenever $D(n)$ is true.
That means we can cite $D(n)$ to justify any step in our proof of $D(n+1)$.
However, instead of citing $D(n)$, we cited $D$(floor (+ $n$ 1) 10).
That's a different proposition,
but it happens that (floor (+ $n$ 1) 10) is strictly smaller than $(n+1)$.
In this proof, we are relying on an inference rule
known as ``strong induction.''
It is equivalent to ordinary mathematical induction,
even though it looks more powerful, since any or all of the
propositions $D(0)$, $D(1)$, \dots $D(n)$ can be cited in the proof of $D(n+1)$.
Ordinary mathematical induction allows citing $D(n)$, but not the other
propositions.
Nevertheless, it is possible verify that if the rule of ordinary mathematical induction
is a valid rule of inference, then so is strong induction, and vice versa.
The proof is not difficult, but it's a distraction,
so we are just going to assume that strong induction works.

\label{strong-induction-rationale}
The \index{induction!rationale}rationale for
\index{induction!proof by}\index{proof!by induction}
\index{strong induction}\index{induction!strong}strong induction is similar to
the rationale for ordinary, mathematical induction (page \pageref{induction-rationale}).
Suppose you are proving the propositions
$P(0)$, $P(1)$, $P(2)$, \dots and so on,
one by one, in sequence.
When you get to the point where you want to prove $P(n+1)$,
you will have already proven all of the propositions
with smaller indices:
$P(0)$, $P(1)$, $P(2)$, \dots $P(n)$.
So, in the proof of $P(n+1)$, you would be able to
cite any of the previous propositions, not just $P(n)$.
When you cite $P(n)$, but not propositions with smaller indices,
in the proof of $P(n+1)$, you are using ordinary mathematical induction.
When you cite one or more propositions with indices smaller than $n$,
you are using strong induction.

To put it another way, the formal statement of the strong induction rule
(Figure~\ref{strong-induction-rule}, page \pageref{strong-induction-rule})
is different from the formal statement of ordinary induction
(Figure~\ref{induction-rule}, page \pageref{induction-rule}), but
in practice strong induction encompasses the ordinary induction rule
as a special case. A proof of $P(n+1)$ that cites only $P(n)$
and not propositions in the predicate $P$ with smaller indices
could cite strong induction because $P(n)$ is one of the propositions
that the \index{hypothesis!induction}\index{induction!hypothesis}strong-induction hypothesis, $(\forall m<n+1.P(m))$, implies are true.
So, we may as well cite strong induction, even when we're only relying
on the ordinary induction rule.

\begin{figure}
\begin{center}
\begin{tabular}{l}
Prove $(\forall m<n.P(m))\rightarrow P(n)$ \\
----------------------------------------\{strong induction\}\\
Infer $(\forall n.P(n))$
\end{tabular}
\end{center}
\index{strong induction}strong\index{induction!strong}
\index{inference rule, by name!\{strong induction\}}
\index{induction!proof by}\index{proof!by induction}
\caption{Mathematical Induction (strong induction version)}
\label{strong-induction-rule}
\end{figure}

\begin{aside}
The inference rule for ordinary mathematical induction
(Figure~\ref{induction-rule}, page \pageref{induction-rule})
requires two proofs above the line:
(1)~Prove $P(0)$ and (2)~Prove $\forall$$n$.(P($n$)$\rightarrow$P($n+1$)).
The strong induction rule
(Figure~\ref{strong-induction-rule})
calls for only one proof:
Prove $(\forall m<n.P(m))\rightarrow P(n)$.
However, when $n = 0$, this is
$(\forall m<0.P(m))\rightarrow P(0)$.
Since there
are no natural numbers less than zero,
$(\forall m<0.P(m))$ true because
a $\forall$ quantification with an empty universe of discourse
is true, by default
(page \pageref{empty-forall}).

So, proving $(\forall m<0.P(m))\rightarrow P(0)$
is the same as proving $True \rightarrow P(0)$,
which is equivalent to proving $P(0)$,
just as in ordinary induction.
In other words, in strong induction there are really two proofs to do,
one for $P(0)$ and one for $(\forall m<n.P(m))\rightarrow P(n)$
when $n$ is not zero, which is usually expressed in the
equivalent form $(\forall m<n+1.P(m))\rightarrow P(n+1)$.
Looking at it this way makes a proof citing strong induction look like
a proof citing ordinary mathematical induction except that
in the proof of $P(n+1)$, the
\index{hypothesis!induction}\index{induction!hypothesis}induction hypothesis
includes all of the propositions $P(0)$, $P(1)$, $P(2) \dots P(n)$, not just $P(n)$.
Therefore, the proof of $P(n+1)$, in a proof by strong induction, can cite any
(or some, or even all) of those propositions to justify steps in the proof.
\index{strong induction}strong\index{induction!strong}\index{induction!proof by}\index{proof!by induction}
\caption{Strong Induction Requires Two Proofs or One?}
\label{strong-induction-rule-2-hyps-or-1}
\end{aside}

\begin{ExerciseList}
\Exercise Let $d$ stand for the number of furlongs in
     the Boston Marathon, not counting the last 165 yards.
     Prove that (nmb10 (dgts $d$)) = $d$
     using the definitions of dgts (page \pageref{dgts-defun})
     and nmb10 (page \pageref{nmb10-defun}),
     but without citing any of the theorems from this section.
\Exercise Define a doublecheck property that tests
     the formula (= (nmb10 (dgts $n$)) $n$) for random
     natural numbers $n$.
     Of course, all of the tests should succeed because
     we proved that the formula always delivers true.
     If a test fails, something is wrong with
     with the definition of the property or operators it refers to.
\Exercise Define a doublecheck property to test the formula
     (equal (dgts (nmb10 $xs$)) $xs$) for random, non-empty
     decimal numerals $xs$.
     \emph{Hint}: (random-list-of (random-between 0 9))
     generates random decimal numerals.
     \emph{Note}: This test can fail.
     If it does, check out the data that causes the failure.
\Exercise We proved that the operator nmb10
     inverts the operator dgts.
     That is, (nmb10 (dgts $n$)) is the same as $n$
     for any natural number $n$ (page \pageref{dgts-ok}).
     However, it is not quite true that dgts inverts nmb10.
     Why not? Give an example of a decimal numeral
     $xs$ for which (dgts (nmb10 $xs$)) is different from $xs$.
\Exercise Describe a class of decimal numerals such that
     that (dgts (nmb10 $xs$)) is the same as $xs$
     when $xs$ is a numeral from that class.
\Exercise Prove that
    (dgts (nmb10 $xs$)) is the same as $xs$
     when $xs$ is a numeral from the class
     you described in the previous exercise.
\Exercise Let $\lfloor log(n) \rfloor$ stand for the
    largest integer for which $10^{\lfloor log(n) \rfloor} \leq n$,
    where $n$ is a non-zero natural number.
    That is, the following inequalities hold.
\index{numeral!length}
\begin{displaymath}
  10^{\lfloor log(n) \rfloor} \le n < 10^{\lfloor log(n) \rfloor + 1}
\end{displaymath}
    Prove the following relationship between the operators
    len (page \pageref{len-equations}) and dgts (page \pageref{dgts-defun}).
\begin{quote}
    (len (dgts $n$)) = $\lfloor log(n) \rfloor + 1$
\end{quote}

\end{ExerciseList}


\section{Binary Numerals}
\label{sec:binary-numerals}

Digital circuits, since they are a materialization of mathematical logic,
have components that can represent two different values.
We call them zero and one, and we choose those names primarily
because circuits that deal with numbers do so in terms of binary numerals.
Decimal numerals require ten different symbols (0, 1, 2, \dots 9)
to represent digits.

\index{bit (binary digit)}Binary numerals only need two (0 and 1) for their binary digits,
which are usually called ``bits'', and that makes them well-suited
for representation in the form of digital circuits.
We will be discussing the design and analysis of circuits to do
arithmetic in terms of binary numerals, so we will need to know
how to construct and interpret them.

Decimal numerals represent numbers as sums of multiples of powers of ten.
Binary numerals are similar, but use two as a base instead of ten.
So, the binary numeral with bits $x_nx_{n-1}\dots x_2x_1x_0$,
where each $x_i$ is either a zero or a one, stands for the number
$(x_0 + x_1 \times 2^1 + x_2 \times 2^2 + \dots + x_{n} \times 2^{n})$.
The only differences between this formula and the one that interprets
decimal numerals is that it has powers of two where the decimal formula had
powers of ten, and the multipliers are bits (0, 1) instead of
digits (0, 1, 2, \dots 9).

Therefore, we can convert the operators for decimal numerals to binary
by simply changing the base from ten to two.
The following definitions of the operators ``bits'' and ``numb''
to construct and interpret binary numerals come directly
from that observation.
Like the corresponding operators for decimal numerals
(dgts, page \pageref{dgts-defun}, and nmb10, page \pageref{nmb10-defun}),
bits and numb use the predicate zp (page \pageref{zp-def}) to choose
between the base case ($n = 0$) and the inductive case ($n > 0$).
ACL2 needs access to the theorems
in the floor-mod book (page \pageref{floor-mod-book})
to admit the bits operator to its logic,
just as it did for the definition of dgts (\pageref{dgts-defun}).

\label{bits-defun}\index{numeral!binary}\index{binary numeral}
\index{operator, by name!bits (numeral from number)}\seeonlyindex{bits}{operator}
\index{equation, by name!\{bits0\}, \{bits1\}}
\index{representation!binary numeral}
\begin{Verbatim}
(defun bits (n)
  (if (zp n)
      nil                                   ; {bits0}
      (cons (mod n 2) (bits (floor n 2))))) ; {bits1}
\end{Verbatim}
\label{nmb-defun}
\index{operator, by name!numb (number from bits)}\seeonlyindex{numb}{operator}
\index{equation, by name!\{numb0\}, \{2numb\}, \{2numb+1\}}
\begin{Verbatim}
(defun numb (xs)
  (if (consp xs)
      (if (= (first xs) 1)
          (+ 1 (* 2 (numb (rest xs)))) ; {2numb+1}
          (* 2 (numb (rest xs))))      ; {2numb}
      0))                              ; {numb0}
\end{Verbatim}

The theorem about numb concerning the interpretation of
binary numerals as numbers and the theorem about the numb
being the inverse of the bits operator are
also true in the new context, and the proofs are similar to the ones
on decimal numerals presented earlier in this chapter.
Constructing those proofs is a good exercise.
It will help you understand decimal numerals better,
and clarify your understanding of binary numerals.

\begin{aside}
A difference between the definition of numb (page \pageref{nmb-defun})
and the definition of nmb10 (page \pageref{nmb10-defun})
is that numb treats bits as symbols,
while nmb10 assumes that they are numbers.
A $1$ in the representation we have chosen for binary numerals
stands for a one-bit. Anything else stands for a zero-bit.
That's why the definition of numb has two equations (\{2numb+1\} and \{2numb\})
for non-empty numerals,
where the definition of nmb10 has only one equation (\{n10.1\}).

There are two motivations for this design decision.
One is that it makes binary numerals entirely symbolic,
with no ephemeral entities like mathematical numbers.
Circuits represent bits symbolically by electronic signals,
so the definition of numb is more closely
related to a circuit than it would be with numbers for bits.

The other motivation is to reduce the number of constraints
in theorems about ACL2 models of circuits.
Bits don't have to be lists of zeros and ones.
Any list is a numeral.
That numeral has one-bits where the elements of the list are ones
and zero-bits where its elements are anything other than ones.
In fact, numerals are entirely unconstrained.
The empty list represents the number zero,
but so does any ACL2 entity $x$ such that (consp $x$) is false.
Many picayune details in theorems about binary numerals
are avoided by this elimination of constraints.
\index{numeral!list representation}
\caption{Representation Trick: Any List is a Binary Numeral}
\label{aside:numeral-representation-trick}
\end{aside}

\begin{ExerciseList}

\Exercise
\label{horner2-thm}
Adapt the proof of \{\emph{Horner 10}\} (page \pageref{horner10-thm})
to prove
\index{theorem!Horner}\index{theorem, by name!\{Horner 2\}}
\index{Horner}theorem \{\emph{Horner 2}\}:
\begin{quote}
(numb [$x_0$ $x_1$ $x_2 \dots$ $x_{n}$])
$= (x_0 + x_1 \times 2^1 + x_2 \times 2^2 + \dots x_{n} \times 2^{n})$
\end{quote}

\Exercise \label{bits-ok}\index{theorem, by name!\{bits-ok\}}
Prove theorem \{\emph{bits ok}\}: ((numb (bits $n$)) = $n$), assuming $n$ is a natural number.
%That is, the operator numb (page \pageref{nmb-defun})
%inverts the operator bits (page \pageref{bits-defun}).

\Exercise \label{nmb1}
\index{equation, by name!\{nmb1\}}\index{theorem, by name!\{nmb1\}}
Prove \{nmb1\}: (numb [$x_0$ $x_1$ $x_2 \dots$ $x_{n}$]) $=$ (numb [$x_0$]) $+$ $2\times$(numb [$x_1$ $x_2 \dots$ $x_{n}$])

\Exercise \label{nmb1-acl2}\index{theorem, by name!\{nmb1\}}
The mechanized logic of ACL2 successfully proves the equation in Exercise \ref{nmb1}.
Use Proof Pad to submit the following statement of the theorem to ACL2.
\begin{Verbatim}
(defthm nmb1
   (implies (consp xs)
            (= (+ (numb (list (first xs)))
                  (* 2 (numb (rest xs))))
               (numb xs))))
\end{Verbatim}

\Exercise Prove theorem \{\emph{len-pad}\}: (len (pad $n$ $x$ $xs$)) = $n$,
where ``pad'' is defined as follows. \\
\begin{samepage}
\label{pad-defun}\index{operator, by name!pad (append padding)}\seeonlyindex{pad}{operator}
\index{equation, by name!\{pad$+$\}, \{pad$-$\}}
\begin{Verbatim}
(defun pad (n x xs)
  (let* ((padding (- n (len xs))))
    (if (natp padding)
        (append xs (rep padding x)) ; {pad+}
        (prefix n xs))))            ; {pad-}
\end{Verbatim}
\end{samepage}
\emph{Note}: The definition of pad refers to the operators
rep (page \pageref{rep-equations}) and prefix (page \pageref{prefix-equations}).
and uses a ``let*'' formula (Aside \ref{let*-def}, page \pageref{let*-def})
to the name ``padding'' with the number of elements to append to $xs$
to form a list of the desired length.

\Exercise \label{hi-1} Prove \{\emph{hi-1}\}:
(fin (bits $n$)) = 1, where fin satisfies the following equations.
\label{fin-defun}
\index{operator, by name!fin (extract last element)}\seeonlyindex{fin}{operator}
\index{equation, by name!\{fin1\}, \{fin2\}}
\begin{Verbatim}
(defun fin (xs)
  (if (consp (rest xs))
      (fin (rest xs)) ; {fin2}
      (first xs)))    ; {fin1}
\end{Verbatim}

\Exercise \label{hi-1-defthm} Express
\index{theorem, by name!\{hi-1\}}theorem \{\emph{hi-1}\}
of the previous exercise in ACL2 notation
and run it through the ACL2 mechanized logic.
ACL2 will succeed if you state the theorem correctly as an implication,
using the predicate posp (Aside \ref{zp-def} , page \pageref{zp-def})
to test for a non-zero, natural number.
Of course the definition of ``bits'' (page \pageref{bits-defun})
will need to be admitted to the logic  (page \pageref{admit-def})
before ACL2 can attempt the proof of this theorem.

\Exercise \label{len-bits}\index{theorem, by name!\{len-bits\}}
Prove \{\emph{len-bits}\}:
$\forall n$.($(2^{n-1} \le m < 2^n) \rightarrow$ ((len (bits $m$)) $= n$))

\Exercise \label{len-bitsLE}\index{theorem, by name!\{len-bits$\le$\}}
Prove \{\emph{len-bits}$\le$\}:
$\forall n$.($(0 \le m < 2^n) \rightarrow$ ((len (bits $m$)) $\le n$))

\Exercise \label{log-bits}\index{theorem, by name!\{log-bits\}}\index{numeral!length}
Prove \{\emph{log-bits}\}:
$\forall n > 0$.((len (bits $n$)) $= \lfloor log_2(n) \rfloor + 1$) \\
\emph{Note}: $\lfloor x \rfloor$ = biggest integer not exceeding $x$

\Exercise \label{leading-0}\index{theorem, by name!\{leading-0\}}
Prove \{\emph{leading-0}\}:
$\forall n$.((numb (append (bits n) (list 0))) = (numb (bits $n$)))

\Exercise \label{leading-0s}\index{theorem, by name!\{leading-0s\}}
\index{leading zero}\index{numeral!leading zero}
Prove \{\emph{leading-0s}\}:
$\forall z$.($\forall n$.((numb (append (bits $n$) (rep $z$ 0))) = (numb (bits $n$)))) \\
Assume that theorem \{\emph{leading-0}\} in the previous exercise
has been proven and that $z$ stands for a natural number.
The operator rep is defined on page \pageref{rep-equations}.

\Exercise \label{leading-0s-defthm} Express theorem \{\emph{leading-0s}\}
of the previous exercise in ACL2 notation
and run it through the ACL2 mechanized logic.
ACL2 will succeed if you state the theorem correctly as an implication,
referring to the predicate ``natp'' to constrain $n$ and $z$ to be natural numbers.
Of course the definitions of ``bits'' and ``numb'' will need to
be admitted to the logic (page \pageref{bits-defun})
before ACL2 can attempt the proof of this theorem.

\Exercise \label{pfx-mod}\index{theorem, by name!\{pfx-mod\}}
Prove \{\emph{pfx-mod}\}:
$\forall w$.($\forall n$.((numb (prefix $w$ (bits $n$))) = (mod $n$ $2^w$))) \\
\emph{Hint}: Induct on $w$. Split the inductive case into two parts,
one part where $n = 0$ and one where $n > 0$, and apply
\{$\vee$ elimination\} (page \pageref{fig-02-deduction-rules}) to complete
the proof of the inductive case.
In the $n > 0$ part, the \{\emph{mod-div}\} theorem
(page \pageref{modular-division}) will be helpful.

%\Exercise We created the definitions of bits and numb
%by copying those of dgts and nmb10, and changing the twos to tens.
%The practice of defining new entities by copying
%old ones and making a few changes can lead to erroors
%(page \pageref{abstraction}).
%It might have been better to define new operators with
%an additional parameter for the base to deal with positional
%numerals with any base.
%\label{numeral-from-number-defun}
%\begin{Verbatim}
%(defun numeral-from-number (b n)
%  (if (zp n)
%      nil
%      (cons (mod n b)
%            (numeral-from-number b (floor n b)))))
%\end{Verbatim}
%\label{number-from-numeral-defun}
%\begin{Verbatim}
%(defun number-from-numeral (b xs)
%  (if (consp xs)
%      (+ (first xs)
%         (* b (number-from-numeral b (rest xs))))
%      0))
%\end{Verbatim}
%Make new definitions of the operators dgts, nmb10, bits, and numb
%that rely on the abstraction of the base in
%the operators numeral-from-number and number-from-numeral.
%
%\Exercise In a manner similar to that suggested in the previous exercise,
%       define operators to convert
%       between numbers and hexadecimal (base 16) numerals.
%
%\Exercise The hexadecimal numerals in the previous exercise
%       use numbers between zero and fifteen to represent
%       hexadecimal digits. Define new operators that use,
%       instead, strings of characters from the set
%       {0, 1, 2, \dots, 9, A, B, C, D, E, F} to represent
%       hexadecimal numerals.
%       While you're at it, represent the numerals as string
%       in the usual ordering from high-order hexadecimal digit to
%       low-order, instead of the reverse order we have been using.
%       You may refer to the operators defined below that convert
%       between hex strings and numerals.
%       Strings in ACL2 are delimited by double-quote characters.
%\begin{Verbatim}
%(defun char-to-digit (chr)
%  (let* ((dgt9  (char-code #\9))
%         (code (char-code chr)))
%    (if (> code dgt9)
%        (+ 10 (- code (char-code #\A)))
%        (- code (char-code #\0)))))
%(defun chars-to-digits (chrs)
%  (if (consp chrs)
%      (cons (char-to-digit (first chrs))
%            (chars-to-digits (rest chrs)))
%      nil))
%(defun digits-to-chars (dgts)
%  (if (consp dgts)
%      (cons (digit-to-char (first dgts))
%            (digits-to-chars (rest dgts)))
%      nil))
%(defun string-to-numeral (str)
%  ; example: (string-to-numeral "41C5") = '(5 11 1 4)
%  (let* ((chrs (coerce (string-upcase str) 'list)))
%    (chars-to-digits (reverse chrs))))
%(defun numeral-to-string (nml)
%  ; example: (numeral-to-string '(5 11 1 4)) = "41C5"
%  (let* ((dgts (reverse nml)))
%    (coerce (digits-to-chars dgts) 'string)))
%\end{Verbatim}

\end{ExerciseList}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
