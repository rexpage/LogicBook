\chapter{Multipliers and Bignum Arithmetic}
\label{ch:multipliers}

%%\textit{shift and add multipliers, \dots}

Chapter \ref{ch:adders} discussed circuits for adding binary numerals of a
fixed word length.
The ACL2 model (Figure \ref{fig:adder}, page \pageref{fig:adder})
assumed that both numerals had exactly $w$ bits, $w$ being the word size.
The circuit diagram reflected this assumption by
showing $2w$ input wires ($w$ lines for each numeral) and
$w$ output wires for the numeral denoting the sum.

The diagram has an additional input wire for the carry bit
coming into the adder (normally a zero bit, unless the circuit is being
used for some sort of multi-word arithmetic) and an additional output wire
for the output carry bit.
The output carry bit is normally ignored in single-word arithmetic
when one addend is positive and the other is negative,
but can be used to detect overflow\footnote{Overflow occurs
when the sum of the two input numerals falls outside
the range of numbers representable in the arithmetic system.}
when they have the same sign.

The ACL2 model received the input carry as its first operand
and the two input numerals as lists of length $w$ as second and third operands.
It delivered its output as a list of two elements,
the first element being a list of $w$ sum bits,
and the second element being the carry out.
The model, like the circuit, did not allow for input numerals
of differing lengths.
That is the usual case for physical circuits.
They have a fixed number of wires and gates.

Software has no such constraint.
A software component for adding binary numerals can accept
numerals of any length, and the two numerals need not have the same length.
The numeral representing the sum would then have as many bits as
required to represent the sum of the numbers
denoted by the input.

An adder expressed in software that is able to deal with numerals
\index{bignum!addition (add, add-1, add-c)}\index{addition!bignum}of
any length is often called a bignum adder.
It performs precise arithmetic on numbers of any size
rather than on a fixed range of numbers based on word size.
To simplify the discussion, we will talk about arithmetic
for non-negative integers only. Similar ideas, but
with serious complications, carry over
to the domain of negative integers.

\section{Bignum Adder}
\label{sec:bignum-adder}

To begin, let's see what it takes to convert our ACL2 model for
the ripple-carry adder to software that performs addition on
binary numerals with an arbitrary number of bits,
representing numbers of unlimited size.
The first step is to work out a way to increment a
binary numeral by one.
That is,
we want to define an operator add1 that, given a
binary numeral $x$ for the natural number $n$, delivers the
binary numeral for $(n+1)$.
The operator will have the following
property with respect to the operators bits and numb from
Section~\ref{sec:binary-numerals} (page \pageref{bits-defun})
for converting between numbers and our representation
of binary numerals. The property is stated in terms of numbers,
but add1 will work directly with numerals,
bypassing entirely the intrinsic numbers of the computer system.
\\
\vspace{2mm}
\hspace*{2cm}
(add-1 $x$) = (bits ($+$ (numb $x$) $1$)\hfill\{add-1 \emph{property}\}

Following our usual practice when we are trying to define an operator,
we assume that someone has already defined it,
and all we have to do is to write some equations that it
would have to satisfy if it worked. If we manage
to come up with equations that are consistent, comprehensive, and computational
(Figure~\ref{fig:inductive-def-keys}, page \pageref{fig:inductive-def-keys})
we will have defined an operator,
and it will be the only operator that makes all of those equations true.

A particularly simple situation occurs when the numeral to be incremented
has no bits in it. The interpretation we settled on
in Chapter \ref{ch:binary-numerals} is that
the empty numeral stands for the number zero
(equation \{numb0\} in the definition of numb, page \pageref{nmb-defun}).
So, incrementing the empty numeral should produce a numeral for the number $1$,
which is the list [$1$].
\\
\vspace{2mm}
\hspace*{2cm}
(add-1 nil) = (list $1$) = (cons $1$ nil)  \hfill \{add1nil\}

Another simple situation occurs when the low-order bit in the
numeral to be incremented is a zero.
In that case, the ouput numeral is
just like the input numeral, except that its
low-order bit is a one rather than a zero.
\\
\vspace{2mm}
\hspace*{2cm}
(add-1 (cons 0 $x$)) = (cons 1 $x$)    \hfill \{add10\}

At this point, we have equations to cover all numerals
that have either no bits at all or a low-order bit
of zero. If we can work out an equation for numerals
with a low-order bit of one, our equations will be comprehensive.
To do this, let's think about the
low-order bit of the incremented numeral.
Since adding a one-bit to a one-bit produces a sum-bit
of zero and a carry-bit of one
(Figure~\ref{fig:half-adder}, page \pageref{fig:half-adder}),
we conclude that the low-order bit of the incremented numeral
is zero.

But, what about the carry-bit? What do we do with that?
It will need to be added to the higher-order bits of
the input numeral. But, that is just a matter of incrementing
the higher-order bits by one.
The higher-order bits are, themselves, a numeral,
and because of our standard assumption that
someone has already defined the operator we need,
we can just use it to increment that numeral.
That is, we can write an inductive equation that the add-1 operator
must satisfy.
\\
\vspace{2mm}
\hspace*{2cm}
(add-1 (cons 1 $x$)) = (cons 0 (add-1 $x$))   \hfill \{add11\}

Now we have three equations.
They are consistent (no overlapping cases) and
comprehensive (all cases covered).
The equations are also computational because the input numeral
on the right-hand side of the inductive equation
\{add11\} is shorter than
the numeral on the left-hand-side of the equation.
Therefore, the equations define the add-1 operator.
All we need to do now is to combine them into an ACL2 definition.

\label{add-1-defun}\index{equation, by name!\{add10\}, \{add11\}}
\index{operator, by name!add, add-1, add-c (\emph{see} bignum)}
\index{add, add-1, add-c (\emph{see} bignum)}
\index{bignum!addition (add, add-1, add-c)}\index{arithmetic!bignum addition}\index{addition!bignum}
\begin{Verbatim}
(defun add-1 (x)
  (if (and (consp x) (= (first x) 1))
      (cons 0 (add-1 (rest x)))      ; {add11}
      (cons 1 (rest x))))            ; {add10}
\end{Verbatim}

It turns out that the \{add1nil\} equation
and the \{add10\} equation can be expressed as one equation because
the ACL2 formula (cons 1 (rest $x$)), which is the proper
translation for the right-hand-side of \{add10\} equation,
also works for the right-hand-side of the \{add1nil\} equation
because (cons 1 (rest nil)) $=$ (cons 1 nil) $=$ (list 1).
This observation reduces the definition from three equations to two,
and completes the definition of the add1 operator.

The ripple-carry adder propagated the carry from each bit position
to the next higher-order bit position.
Each bit position involved three input bits
(a carry and one bit from each addend).
Our bignum adder will do that, too.
Each bit in the sum will depend on the
corresponding bits in the addends and the carry from
the previous, lower-order bit.

We already have the apparatus for this: the full-adder operator
(Figure~\ref{fig:full-adder},  page \pageref{fig:full-adder}).
We can use that operator, to add two corresponding bits,
$x_n$ and $y_n$, from the addend numerals,
incorporating the carry, $c_n$, from the lower-order bit position.
The full-adder delivers the sum bit, $s_n$, for the current
bit position and the carry bit, $c_{n+1}$, for the next bit position.
\begin{center}
[$s_n$ $c_{n+1}$] = (full-adder $c_n$ $x_n$ $y_n$)
\end{center}

This analysis provides the basis for
one of the equations for the bignum adder.
The equation is inductive and applies
when neither addend is the empty numeral,
so that both have low-order bits.

\begin{center}
\begin{tabular}{ll}
(add $c_0$ [$x_0$ $x_1$ $x_2$ \dots ] [$y_0$ $y_1$ $y_2$ \dots ]) = [$s_0$ $s_1$ $s_2$ \dots ]   & \{addxy\} \\
where & \\
$[s_0$ $c_1] =$ (full-adder $c_0$ $x_0$ $y_0$) & \\
$[s_1$ $s_2 \dots ] =$ (add $c_1$ $[x_1$ $x_2 \dots ]$ $[y_1$ $y_2 \dots ]$) & \\
\end{tabular}
\end{center}

This equation covers all addends whose numerals have at least one bit.
So, all we need to do to make our equations comprehensive
is to have equations for the cases when one or the other addend is an empty numeral.

If either addend is an empty numeral, then that addend denotes the number zero.
The sum, then, would be the other addend with the carry added to it.
We already have an operator, add1 (page \pageref{add-1-defun}),
that we can use to add the carry if it's a one-bit.
When the carry is a zero-bit, we don't need to add the carry bit
because adding zero doesn't change the number.
We define an operator add-c that uses add-1 to add the carry bit
when it is a one.

\label{add-c-defun}\index{equation, by name!\{addc0\}, \{addc1\}} \index{add, add-1, add-c (\emph{see} bignum)}\index{bignum!addition (add, add-1, add-c)}\index{addition!bignum}
\begin{Verbatim}
(defun add-c (c x)
  (if (= c 1)
      (add-1 x)  ; {addc1}
      x))        ; {addc0}
\end{Verbatim}

We also use add-c to complete the addition when either of the addends is empty.
\begin{center}
\begin{tabular}{ll}
(add $c$ $x$ nil) = (add-c $c$ $x$)   & \{add10\} \\
(add $c$ nil $y$) = (add-c $c$ $y$)   & \{add01\} \\
\end{tabular}
\end{center}

That covers all of the cases.
Figure~\ref{fig:bignum-add-defun} (page \pageref{fig:bignum-add-defun})
translates the equations into ACL2.

\begin{figure}
\begin{Verbatim}
(defun add (c0 x y)
  (if (not (consp x))
      (add-c c0 y)                                   ; {add0y}
      (if (not (consp y))
          (add-c c0 x)                               ; {addx0}
          (let* ((x0 (first x))
                 (y0 (first y))
                 (a  (full-adder c0 x0 y0))
                 (s0 (first a))
                 (c1 (second a)))
            (cons s0 (add c1 (rest x) (rest y))))))) ; {addxy}
\end{Verbatim}
\index{equation, by name!\{add0y\}, \{addx0\}, \{addxy\}}
\index{add, add-1, add-c (\emph{see} bignum)}
\index{addition!carry}
\index{numeral!bignum addition}\index{addition!bignum}
\index{arithmetic!bignum addition}
\index{bignum!addition (add, add-1, add-c)}
\caption{Bignum Operator for Adding Binary Numerals}
\label{fig:bignum-add-defun}
\end{figure}

Let's look at some examples of adding numerals with bignum add.
\begin{center}
\begin{tabular}{lllll}
(add $0$ [$0$ $1$]             &[$0$ $1$]~~~~)  &$=$ &[$0$ $0$ 1]           & ~~$2 + 2 = 4$   \\
(add $0$ [$0$ $1$ $1$ $1$]     &[$1$ $0$ $1$]~) &$=$ &[$1$ $1$ $0$ $0$ $1$] & ~~$14 + 5 = 19$ \\
(add $0$ [$1$ $0$ $0$ $1$ $1$] &[$0$ $1$ $1$]~) &$=$ &[$1$ $1$ $1$ $1$ $1$] & ~~$25 + 6 = 31$ \\
\end{tabular}
\end{center}

The properties that the bignum add operator is designed to satisfy
deliver a binary numeral for the sum of
the numbers represented by the input numerals and the input carry.
The examples show that the property holds for three
particular pairs of addends.
Of course we would like to know that it
holds for all input numerals, and
the following theorem makes that assertion formally.

\label{bignum-adder-thm}\index{theorem!bignum addition}\index{theorem, by name!\{bignum-add-ok\}}\index{bignum!addition (add, add-1, add-c)}\index{addition!bignum}
\begin{Verbatim}
(defthm bignum-add-ok
  (= (numb(add c x y))
     (+ (numb (list c)) (numb x) (numb y))))
\end{Verbatim}

The ACL2 system succeeds in proving this theorem by induction,
and we could do a paper-and-pencil proof following a strategy
similar to the one for the \{adder ok\} theorem about the ripple-carry adder
(Figure~\ref{fig:adder-thm-prf}, page \pageref{fig:adder-thm-prf}).
In any case, we know now, to a mathematical certainty,
that the bignum add operator delivers
the sum of its two input numerals and the input carry bit.

\begin{ExerciseList}
\Exercise \label{bignum-add-hi-order-bit-thm}
Do a pencil-and-paper proof by induction of the following
theorem, which says that if the high-order bit in both input numerals is a one-bit,
then the high-order bit of the numeral delivered
by the bignum add operator is also a one-bit.
The theorem refers to the fin operator (page \pageref{fin-defun}).

\Exercise State the theorem of Exercise~\ref{bignum-add-hi-order-bit-thm}
in ACL2 and submit it to the mechanized logic.
ACL2 will succeed in proving a proper statement of the theorem.
\end{ExerciseList}

\section{Shift-and-Add Multiplier}
\label{sec:bignum-mult}

The grade-school method of multiplying multi-digit numbers proceeds one digit at a time,
from right (low-order digit of the decimal numeral) to left (higher order digits).
The first step is to multiply the entire multiplicand by the low-order digit
of the multiplier.
Then comes the next-to-last digit of the multiplier (the tens digit) for the second step.
In the second step, the product is written below the one from the first step,
but shifted left one position.
This continues across all of the digits of the multiplier, one by one,
writing the products shifted one more position to the left at each step.
After the products are completed for
all the digits in the multiplier, they are totaled, taking care to keep
the digits lined up according to the left shifts that occurred at each stage.

Grade-school students learn this procedure without knowing
the algebra behind it. However, we want to specify the operations in
the form of equations, so we need to work out the algebra.
Figure~\ref{fig:grade-school-mult} (page \pageref{fig:grade-school-mult})
presents the multiplication procedure,
and provides an algebraic argument that justifies it.
The algebra relies on the equation
that grade-school students use to check the correctness of their long-division problems.

\hspace{2mm} $x = (\lfloor x \div d \rfloor \cdot d) + $($x$ mod $d)$ \hfill \{check$\div$\}\footnote{As
usual $\lfloor x\rfloor$ stands for the greatest integer that is $x$ or less,
and $(x$ mod $d)$ is the remainder when $x$ is divided by $d \neq 0$ (modular arithmetic,
Aside~\ref{third-grade-division}, page \pageref{third-grade-division}).}
\vspace{2mm}

Since grade-school students use decimal numerals,  $d = 10$.
The remainder ($x$ mod $10$) is the last digit in the numeral for the number $x$,
and the other digits are those of the quotient $\lfloor x \div 10 \rfloor$.
That goes for any number, and
Figure~\ref{fig:grade-school-mult}
parlays this idea to elucidate digit-by-digit multiplication.

\begin{figure}
\emph{Nomenclature}
\begin{center}
\begin{tabular}{ll}
$x$                         &number represented by the numeral of the multiplier\\
$x_0$ $=$ $x$ mod $10$      &low-order digit of the numeral for $x$\\
$\lfloor x\div 10\rfloor$   &number represented by the other digits of the numeral for $x$\\
$y$                         &number represented by the numeral of the multiplicand\\
$m$   $=$ $x_0\cdot y$      &product of $y$ and the low-order digit of $x$\\
$p$   $=$ $\lfloor x\div 10\rfloor\cdot y$ &product of $y$ and the number represented by other digits of $x$\\
$m_0$ $=$ $m$ mod $10$      &low-order digit of the numeral for $m$\\
$\lfloor m\div 10\rfloor$   &number represented by the other digits of the numeral for $m$\\
$s$   $=$ $\lfloor m\div 10\rfloor + p$    &sum of $p$ and the number represented by the other digits of $m$\\
$x y$ $=$ $s\cdot 10 + m_0$ &shift the numeral for $s$ and bring down digit $m_0$\\
\end{tabular}
\end{center}

\emph{Procedure}
\begin{quote}
\begin{enumerate}
\item \emph{Low-Order Digit}:
Multiply the multiplicand, $y$, by the low-order digit, $x_0$,
of the numeral for the multiplier, $x$: $m = x_0\cdot y$.

\item \emph{Digit by Digit}:
Multiply $y$ by the number
represented by the other digits of the numeral for $x$:
$p=\lfloor x\div 10\rfloor\cdot y$.

\item \emph{Shift and Add}:
Add $p$ to the number represented by
the other digits of the numeral for $m$: $s = p + \lfloor m\div 10\rfloor$.
(In grade-school terminology, this is the step where you
shift and add.)

\item \emph{Bring It Down}:
Observe that the low-order digit, $m_0$, of $m$
is the low-order digit of the numeral for the product $x y$.
(In grade-school terminology,
this is the step where you bring down the digit $m_0$.)

\item \emph{Deliver Numeral for $x y$}:
Form a numeral whose low-order digit is $m_0$ (the one you brought down)
and whose other digits are those of the numeral for $s$.
\end{enumerate}
\end{quote}

\emph{Justification}
\begin{center}
\begin{tabular}{cll}
    & $x y$ & \\
$=$ & $(\lfloor x \div 10\rfloor \cdot 10 + (x$ mod $10)) y$  & \{\emph{check}$\div$\} (page \pageref{third-grade-division})\\
$=$ & $(\lfloor x \div 10\rfloor \cdot 10 + x_0) y$           & \{$x_0=x$ mod $10$\}\\
$=$ & $(\lfloor x \div 10\rfloor \cdot y) \cdot 10 + x_0 y$   & \{\emph{algebra}\} \\
$=$ & $(\lfloor x \div 10\rfloor \cdot y) \cdot 10 + m$       & \{$m=x_0\cdot y$\} \\
$=$ & $p \cdot 10 + m$                                        & \{$p=\lfloor x \div 10\rfloor \cdot y$\} \\
$=$ & $p \cdot 10 + \lfloor m \div 10 \rfloor \cdot 10 + (m$ mod $10)$& \{\emph{check}$\div$\} \\
$=$ & $(p + \lfloor m \div 10 \rfloor) \cdot 10 + (m$ mod $10)$       & \{\emph{algebra}\} \\
$=$ & $s \cdot 10 + (m$ mod $10)$                             & \{$s=p + \lfloor m \div 10 \rfloor$\} \\
$=$ & $s \cdot 10 + m_0$                                      & \{$m_0=m$ mod $10$\} \\
\end{tabular}
\end{center}
\label{multiplication!grade school}
\caption{Grade-School Multiplication: Digit by Digit}
\label{fig:grade-school-mult}
\end{figure}

Of course, our bignum multiplier
will use binary numerals rather than decimal numerals.
The procedure is the same, but permits some economies
because the multiplication table for bits is much simpler
than for decimal digits.
We are looking for some equations that define a multiplication operator.
That is, an operator that delivers the binary numeral for the product of the numbers
represented by its operands, which are also binary numerals.
Let's call it mul, and let's call its operands, which are binary numerals,
$x$ and $y$ (Section~\ref{sec:binary-numerals}, page \pageref{sec:binary-numerals}).
If $y$ is nil, it stands for zero, which makes the product zero, represented by nil.
That gives us one equation.

\hspace*{2cm} (mul $x$ nil) = nil \hspace{2cm} \hfill \{mulx0\}
\\

That completes the computation when $y$ is nil,
so we can now focus on the case when $y$ is not nil.
For this case, we are going to invoke another operator, mxy,
that assumes $y$ is not nil. That gives us the other equation
for mul.

\hspace*{2cm} (mul $x$ $y$) = (mxy x y), if (consp $y$) \hfill \{mulxy\}
\\

Now, we turn our attention to defining mxy, which multiplies binary
numerals $x$ and $y$, assuming that $y$ is not an empty numeral.
It may happen that $x$ is empty, which stands for zero, so that
the product is also zero, and in that case (mxy $x$ $y$) is nil,
which gives us one of the equations for mxy.

\hspace*{2cm} (mxy nil $y$) = nil  \hfill \{mul0y\}
\\

That leaves the case when $x$ $=$ [$x_0$ $x_1$ $x_2$ ...] is not empty.
Follow along, again, in Figure~\ref{fig:grade-school-mult},
but this time, because we're in binary mode, think $2$ when you see $10$,
and think bits where you see digits.
We'll discuss step 1 shortly, but first look at step 2,
which will be necessary, regardless of what happens in step 1.
Step 2 requires the computation of
$p = \lfloor x \div 2 \rfloor \cdot y$.
The numeral for $\lfloor x \div 2 \rfloor$ is just $x$ without its
low-order bit: numeral for $\lfloor x \div 2 \rfloor =$ (rest $x$).
Since the numeral (rest $x$) is shorter than $x$,
we can simply invoke mxy, relying on induction.
That gives us a way to compute $p$, which, don't forget,
is a numeral at this point, not a number.

\hspace*{2cm} $p$ = (mxy (rest $x$) $y$)) \hfill \{mul.p\}
\\

Binary numerals make the first step of the
multiplication procedure ($m = x_0 \cdot y$)
simpler than with decimal numerals.
The bit $x_0$ is either a zero or a one.
If it's a zero, $m = m_0 = 0$, so all
we have to do is multiply $p$ by $2$ (just shift, no add).
Multiplying a binary numeral by $2$ is a matter
of inserting a zero in at the beginning.
(This is where we bring down a zero.)
So, when $x_0 = 0$, we get the following equation for mxy.

\begin{figure}
\begin{Verbatim}
(defun mxy (x y) ; assumption: y is not nil
  (if (consp x)
      (let* ((p  (mxy (rest x) y)))             ; {mul.p}
        (if (= (first x) 1)
            (cons (first y) (add 0 p (rest y))) ; {mul1xy}
            (cons 0 p)))                        ; {mul0xy}
      nil))                                     ; {mul0y}

(defun mul (x y)
  (if (consp y)
      (mxy x y) ; {mulxy}
      nil))     ; {mulx0}
\end{Verbatim}
\label{bignum-mul-defun}\index{arithmetic!bignum multiplication}\index{multiplication!bignum}\index{bignum!multiplication (mul, mxy)}\index{numeral!binary multiplication}\index{multiplication!binary numerals}\index{binary numeral!multiplication}\index{operator, by name!mul, mxy (\emph{see} bignum)}\index{mul, mxy (\emph{see} bignum)}\index{equation, by name!\{mul0y\}, \{mul0xy\}, \{mul1xy\}}\index{equation, by name!\{mulx0\}, \{mulxy\}}
\caption{Bignum Multiplication Operator}
\label{fig:bignum-mul-defun}
\end{figure}

\hspace*{2cm} (mxy [$0$ $x_1$ $x_2$ \dots] $y$) = (cons $0$ $p$) \hfill \{mul0xy\}
\\

If $x_0 = 1$, then $m = y$,
so $s = \lfloor m\div 2\rfloor + p = \lfloor y\div 2\rfloor + p$.
Again, $y$ is a numeral, so the numeral for $\lfloor y\div 2\rfloor$
is just like $y$, but without the first bit: (rest $y$).
That gives us another equation for mxy.
We use the bignum add operator to compute the sum in step 3
of the multiplication procedure.
The first operand of the add operator is the input carry bit,
which is zero because we only want to add $p$ and (rest $y$).
We bring down the low-order bit of $m$, but $m = y$
($x_0 = 1$, you remember), so that's (first $y$).

\hspace*{2cm} (mxy [$1$ $x_1$ $x_2$ \dots] $y$) = (cons (first y) (add 0 (rest y) p) \hfill \{mul1xy\}
\\

These equations for mul are comprehensive because $y$ is either empty,
in which case equation \{mulx0\} applies,
or $y$ is not empty, in which case \{mulxy\} applies, and
the computation is left up to the operator mxy,
so we have to analyze the definition of mxy.

The equations in the definition of mxy are comprehensive
because either $x$ is empty, in which case
equation \{m0y\} applies, or $x$ is not empty.
If $x$ is not empty, its low-order bit is either zero,
in which case equation \{m0xy\} applies, or it is one,
in which case equation \{m1xy\} applies.

The equations are consistent because in the one case
where they could overlap, namely when both $x$ and $y$
are empty, they deliver the same result, namely the empty numeral.

They are computational because in the inductive equations,
\{m0xy\} and \{m1xy\}, the first operand in
the invocation of the operator mxy on the right-hand side,
is the numeral (rest $x$). Since $x$ is non-empty in the inductive case,
(rest $x$) has fewer bits than the $x$, which is the first operand
on the left-hand side.
So, the inductive invocation is closer to a non-inductive
case than the formula on the left-hand side of the equation.

Putting this all together leads to the ACL2 definition
of the bignum multiplication operator mul in
Figure~\ref{fig:bignum-mul-defun} (page \pageref{fig:bignum-mul-defun}.
Most of the work is done by the operator mxy.
From these definitions, ACL2 successfully finds an
inductive proof of the following theorem,
which confirms that (mul $x$ $y$) is the binary numeral
for the product of the numbers that the numerals $x$ and $y$ represent.

\label{bignum-mul-thm}\index{theorem!bignum multiplication}\index{theorem, by name!\{bignum-mul-ok\}}\index{arithmetic!bignum multiplication}\index{bignum!multiplication (mul, mxy)}\index{multiplication!bignum}
\begin{Verbatim}
(defthm bignum-mul-ok
  (= (numb (mul x y)) (* (numb x) (numb y))))
\end{Verbatim}

\begin{ExerciseList}
\Exercise
Use an induction on the number of bits in the
multiplier to do a paper-and-pencil proof of
the bignum multiplier theorem, bignum-mul-ok.
\end{ExerciseList}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
