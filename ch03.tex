\chapter{Software Testing and Prefix Notation}
\label{ch:software-testing-prefix-notation}

\todo{ leaving this material on the reciprocals function here just in case we want to go back to it later - rlp(8Sep2017)
Suppose you have purchased a piece of software from someone, 
and you want to take it for a test drive to see if it works. 
Let's say it's the function that delivers sum of the first $n$ reciprocals, given a number $n$.
You've seen this function before (page \pageref{reciprocalsdef}).
\begin{displaymath}
r(n) = 1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n}
\end{displaymath}

You could start with a few simple checks.
\begin{displaymath}
 r(1) = 1
\\
 r(2) = \frac{3}{2}
\\
 r(2) = \frac{11}{6}
\end{displaymath}

That gets old fast. It would be nice to do a whole bunch of tests,
not just a few specific ones.
One way to describe a lot of tests at once is to find a way to specify
a relationship among values of the function that you know will always be true.
For example, you know that $reciprocal(n)$ is just like $reciprocal(n-1)$,
except that it has one more term in the sum.
\begin{quote}
\begin{tabbing}
$r(n)$ \=$= (1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{(n - 1)})$ $+ \frac{1}{n}$ \\
\vspace{1 mm}
                 \>$= r(n-1) + \frac{1}{n}$
\end{tabbing}
\end{quote}

This relationship provides a different test for each possible value of $n$.
You could tell the computer to run thousands of tests
using random values for $n$ and have it report an error any of the tests fail.
If the computer encounters errors, you will of course want your money back.

Since you do not expect the function to work unless the input
is a non-negative integer, you need to tell the computer
to choose random numbers of that kind.
In fact, the test as it stands doesn't work when $n$ is zero,
so we need to fix that problem, either by avoiding zero
in the testing process or by modifying to test to deal with zero.
\begin{displaymath}
r(n) =
\left\{
        \begin{array}{ll}
                0            & \mbox{if } n = 0 \\
                r(n-1) + 1/n & \mbox{otherwise}
        \end{array}
\right.
\end{displaymath}

After this modification, the computer can run thousands of tests automatically,
just by choosing random, non-negative, integer values for $n$,
computing $r(n)$ and $r(n-1) + 1/n$,
and checking to make sure they are the same.
If zero comes up as the random input,
the computer compares $r(n)$ to zero instead of
$r(n-1) + 1/n$.
---------------- end of todo inserted to retain material on reciprocals function, just in case}

We will be using a software development environment that automates parts of the software testing process.
To use it, we can define tests that check results corresponding to inputs provided directly in the test.
Or, we can ask the system to generate certain kinds of random data check results
against logic formulas specifying properties that we expect of the results.

\begin{aside}
Proof Pad is a tool that provides a convenient way
to write, test, and reason about programs
written in the ACL2 dialect of a programming language called Lisp.
ACL2 includes a mechanized logic that
supports rigorous checking of the reasoning process,
and we will use it for that purpose starting in this chapter.

We will begin to use Proof Pad in this chapter,
so you should install it on your computer.
To install Proof pad, follow the instructions at \url{http://proofpad.org}.
If that link fails, look for ``Proof Pad''
with your web search engine.
They are well-known systems and should be easy to find.
They are free, too.
\label{aside:proof-pad}
\caption{Proof Pad and ACL2}
\end{aside}

To get the syntax straight, let's specify some direct tests that Proof Pad
can carry out for the addition operator.
The following tests check some equations that we expect to be true: 
$2 + 2 = 4$, $5 + 7 = 10 + 2$, etc.

\begin{Verbatim}
(include-book "testing" :dir :teachpacks)
(check-expect (+ 2 2) 4)
(check-expect (+ 5 7) (+ 10 2))
(check-expect (+ 27 6) (+ (+ 23 5) (+ 2 2)))
\end{Verbatim}

This notation looks strange, with formulas like (+ $2$ $2$) instead of $2 + 2$.
ACL2 uses a prefix notation to denote operations, rather than the infix notation
that you are accustomed to.
In ACL2's prefix notation, a computational formula starts with a parenthesis,
followed by the operator it invokes. 
The operator comes first (as a ``prefix''), then the operands.
Infix notation places the operator between the operands,
and prefix puts it before the operands.

That seems simple enough, but it gets gradually more unfamiliar
as the formulas get more complicated.
For example, a formula for the sum of $x$ and three times $y$, $(x + 3*y)$,
comes out as (+ $x$ ($*$ $3$ $y$)) in prefix form.
This will take a little getting used to,
but is a lot easier to get good at than
most of the stuff you have been studying.
We hope you will be willing to accept it as just another way of writing formulas.
One advantage is the formulas are, by default, fully parenthesized,
so there is never any question about what operands go with which operators.
Some people end up liking the prefix format better than infix.
We will use both, in different contexts, depending on whether
we're doing paper-and-pencil reasoning or formal, mechanized logic.

Another strange element is the include-book directive.
The facility for tests of this kind resides in an ACL2 book
known as "testing", which in turn resides in a directory known
as :teachpacks (with the leading colon). 
The include-book directive tells the system
the name of the testing package and where to find it. 
This boilerplate is needed (including the keyword :dir, with the leading colon)
whenever you want to use check-expect testing,
even though we won't repeat it in all of our examples.
If you install Proof Pad and put these tests in a file
with the .lisp extension (plusoptests.lisp, for example),
you can use Proof Pad to run the tests. 
The first tests two pass without fanfare,
but the third test has a mistake. 
We should not expect that $27 + 6 = (23 + 5) + (2 + 2)$.
The system reports that the assertion failed.
If you change the 6 to 5, the test will pass, as it should.
Normally, when we run tests, we want to know whether the
operator is doing the right thing, 
but in this case the operator ($+$) was fine.
It was the test that was wrong.

Direct, one-off, check-expect tests 
are a good way to get started, but 
we will want to test more general properties that we specify with logic formulas.
Proof Pad facilitates that kind of testing with a package called doublecheck
that generates random data to run against a predicate 
(that is, a formula representing a true/false value).
To demonstrate the idea, consider testing the addition operator to see if
it conforms to the associative law for addition: $(x + (y + z)) = ((x + y) + z)$
(\{+ associative\}, Figure~\ref{fig-02-01}, page \pageref{fig-02-01}).
To do that, we define a property as an equation
and directs Proof Pad to generate some random numbers and
report whether or not the equation holds on all of the random data.

\begin{Verbatim}
(include-book "doublecheck" :dir :teachpacks)
(defproperty +associative-test
  (x :value (random-integer)
   y :value (random-integer)
   z :value (random-integer))
  (= (+ x (+ y z))
     (+ (+ x y) z)))
\end{Verbatim}

The Proof Pad environment ``doublecheck'' package, 
like the ``testing'' package,
resides in the teachpacks directory,
and an include-book directive is required so that Proof Pad where to find it.

A property definition with doublecheck begins with a parenthesis, then the keyword
defproperty and a name for the property to be tested, 
which is ``+associative-test'' in this case.\footnote{The 
rules for naming things in ACL2 are lax, compared to many 
programming languages. Names can be made up of letters and digits, of course,
but can also include some special characters, 
such as plus signs and colons (not semicolons, though).}
A sequence of data generator specifications follows the name of the property.
The entire sequence is enclosed in parentheses,
and each specification has three parts: a name, the keyword :value (with the leading colon),
and a generator, also enclosed in parentheses.
In this case, the definition says to use random integers. 
Doublecheck is able to generate many kinds of random data,
and we will gradually introduce different data generators as the story progresses.
Finally, a predicate formula specifies the test.
In this case, the predicate is an equation,
written of course in prefix notation.

Let's look at another example.
\label{list-op-informal}
The operator ``list'' creates a list of its operands 
(any number of operands), and
\label{append-op-informal}
the operator ``append'' concatenates two lists. 
A few check-expect tests may clarify what the append operator does.
We defer, for now, more formal specifications for the append and list operators.

\begin{Verbatim}
(check-expect (append (list 1 2 3 ) (list 4 5)) (list 1 2 3 4 5))
(check-expect (append (list 9 8 7) (list 6) (list 9 8 7 6))
(check-expect (append (list 11 7) (list 2 5 3)) (list 11 7 2 5 3))
(check-expect (append (list 2 0) (list 1 8)) (list 2 0 1 8))
\end{Verbatim}

We would anticipate that the length of a concatenation of two lists
would be the length of the first list plus the length of the second.
\label{len-op-informal}
Using the ``len'' operator, which computes the length of a list,
we can state this property in a doublecheck test.
Later, we will prove this relationship between append and len,
but for the moment we confine ourselves to stating properties 
and asking Proof Pad to check them against random data.

\label{additive-lengths-test}
\begin{Verbatim}
(defproperty additive-lengths-test
  (xs :value (random-list-of (random-integer))
   ys :value (random-list-of (random-integer)))
  (= (len (append xs ys))
     (+ (len xs) (len ys))))
\end{Verbatim}

\begin{aside}
A ``natural number'' is a whole number (that is, an integer)
that is zero or bigger.
Some mathematical treatments start the naturals at one,
rather than zero, but in the computing domain, 
it simplifies a lot of formulas to start the natural numbers at zero. 
\caption{Natural Numbers}
\label{natural-number-def}
\end{aside}

When we discuss computer arithmetic, we will need to know something about
arithmetic on finite sets of numbers, and the ``mod'' operator will play a crucial role.
\label{mod-function}
The mod operator takes two operands and
delivers the remainder in the division of the first operand by the second.
ACL2 does not restrict the operands to the set of natural numbers,
but in this discussion, we are going to stick with that domain.
Think long division: divisor, dividend, quotient,
remainder . . . third-grade stuff.

Let's test drive the mod operator, starting with
some simple checks, such as using mod 
to compute the remainder when dividing by two,
which will produce zero for even numbers and one for odd numbers.

\begin{Verbatim}
(check-expect (mod 12 2) 0)
(check-expect (mod 27 2) 1)
\end{Verbatim}

Here are a few more sanity checks, this time with three as the divisor.

\begin{Verbatim}
(check-expect (mod 14 3) 2)
(check-expect (mod  7 3) 1)
(check-expect (mod 18 3) 0)
\end{Verbatim}

\begin{aside}
Modular arithmetic (sometimes called ``clock arithmetic'')
deals with integers in a fixed range, $0 \dots (m - 1)$,
where $m$ is an integer greater than zero known as
the ``modulus''.
If $x$ is an integer, the formula ($x$ mod $m$) stands for
the remainder in the division of $x$ by $m$.

Modular addition, subtraction, and multiplication are
are consistent with ordinary arithmetic.
That is, the sum of two numbers, mod $m$,
is the same as the sum, mod $m$, of the corresponding numbers
in the ``mod $m$'' range.
The same is true of subtraction and multiplication.

\begin{quote}
($(x + y)$ mod $m$) = ((($x$ mod $m$) $+$ ($y$ mod $m$)) mod $m$) \\
($(x - y)$ mod $m$) = ((($x$ mod $m$) $-$ ($y$ mod $m$)) mod $m$) \\
($(x \times y)$ mod $m$) = ((($x$ mod $m$) $\times$ ($y$ mod $m$)) mod $m$)
\end{quote}

The ACL2 operator ``mod'' converts numbers to the modular range
for a given modulus. That is, (mod $x$ $m$) delivers the remainder
in the division of $x$ by $m$.
The divisor (second operand) must be non-zero. 
ACL2 does not restrict the operands to natural numbers, 
but the discussion here assumes that they are.
\caption{Clock Arithmetic}
\label{modular-arithmetic}
\end{aside}

We can put ``mod''
through its paces on a large number of tests using doublecheck,
but for that we will need to come up with relationships
that express more general properties of division and remainders.
One such property is that the remainder doesn't change
when the divisor is added to the dividend.

\begin{Verbatim}
(defproperty mod-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (= (mod dividend divisor)
       (mod (+ dividend divisor) divisor))))
\end{Verbatim}

Generating random data is an art.
In this example, we have made sure the divisor isn't zero
by adding one to a natural number. 
Since negative numbers aren't natural numbers, adding one
to a natural number ensures that the sum is non-zero.
\label{let-example-brief-explain}
The definition of the property uses a ``let*'' binding,
which is a way to attach names to values
and then use those names in a formula that comes after the bindings.\footnote{The 
parentheses in a let* binding 
are tricky. Each individual binding is enclosed in parentheses,
and the whole sequence of bindings is closed in another set
of parentheses. The ``let*'' keyword precedes the bindings
and a formula follows the bindings.
Any of the names attached to values in the bindings
can be used in the formula to denote those values.
Finally, the entire let* construct (keyword, bindings, and formula)
is enclosed in parentheses.
The let* construct delivers the value of the formula
that comes at the end.
}
In this case, the let* binding says that
the name ``divisor'' will be used to stand for 
the value represented by the formula (+ divisor-minus-1 1).
To see the testing facility in action,
define the ``mod-test'' property in a .lisp file,
and use Proof Pad to run the tests.

Another property of the mod operator
in the domain of natural numbers 
is that the remainder
is always smaller than the divisor.
That is, (mod dividend divisor) < divisor.
The following property definition uses
the doublecheck testing facility
to test whether the mod function delivers values in this range.

\begin{Verbatim}
(defproperty mod-upper-limit-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (< (mod dividend divisor) divisor)))
\end{Verbatim}

In this test, the property is not expressed as an equation,
but as an inequality
specified with the less-than operator ($<$).
As always, the formula puts the operator in the prefix position,
in front of its operands.
For practice, add this property to the .lisp file with the other tests and run it.

Another fact about remainders in division in the domain of natural numbers is that
they are non-negative integers (that is, natural numbers).
We can use the logical-and operator (``and'' is the ACL2 name for $\wedge$)
to combine the upper-limit test with the natural-number test.
in one property definition.
\label{natp-op}
The value of the formula ``(natp $x$)'' is true
if $x$ is a natural number and false if it isn't.

\label{natp-axiom-formal}
\begin{center}
Axiom \{\emph{natp}\} \\
(natp $x$) $=$ $x$ \emph{is a natural number}
\end{center}

\begin{Verbatim}
(defproperty mod-range-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (and (natp (mod dividend divisor))
         (< (mod dividend divisor) divisor))))
\end{Verbatim}

\begin{aside}
Maybe you think ``floor'' is an odd name
for a function that produces the quotient, but wait \dots it gets worse.
Names a lot stranger than that will pop up soon enough.
The floor operator delivers the quotient. Get used to it.
There's no crying in baseball.
\caption{Think ``floor'' is an odd name?}
\label{floor-is-odd}
\end{aside}

There are two parts to the result
of dividing one number by another: the quotient and the remainder.
The mod operator delivers the remainder,
\label{floor-def}
and an operator called ``floor'' delivers the quotient.
The quotient is always strictly smaller
than the dividend when the divisor is bigger than one
and the dividend is a non-zero, natural number.
The following test checks for that property.
The random-value generator for the divisor
makes sure the divisor exceeds one by adding two
to a natural number.
Similarly, we make sure the dividend isn't zero by adding one.

\label{quotient-less-than-dividend-test}
\begin{Verbatim}
(defproperty quotient-less-than-dividend-test
  (divisor-minus-2   :value (random-natural)
   dividend-minus-1  :value (random-natural))
  (let* ((divisor  (+ divisor-minus-2 2))   ; divisor  > 1
         (dividend (+ dividend-minus-1 1))) ; dividend > 0
    (< (floor dividend divisor)
       dividend)))
\end{Verbatim}

Checking the result of a division is a matter
of multiplying the quotient by the divisor and adding the remainder.
If this fails to reproduce the dividend,
something has gone wrong in the division process.
The following property tests this relationship
between the mod and floor operators.
It needs to use the multiplication operator, which is denoted by an asterisk.

\label{division-check-test}
\begin{Verbatim}
(defproperty division-check-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (= (+ (* divisor (floor dividend divisor))
          (mod dividend divisor))
       dividend)))
\end{Verbatim}

We hope by now you are starting to get comfortable with prefix notation
and the Proof Pad test facilities.
The exercises will give you a chance to practice.

\begin{ExerciseList}
\Exercise Define a test of the floor operator
that checks to make sure its value is a natural number
when its operands are natural numbers,
and the divisor (second operand) is not zero.
Use Proof Pad to run the test.

\Exercise The ``max'' operator chooses the larger of two numbers:
(max 2 7) is 7, (max 9 3) is 9.
Define a doublecheck property that tests to make sure
(max $x$ $y$) is greater than or equal to (>=) both $x$ and $y$.
Use Proof Pad to run tests of the property.

\Exercise
Define a doublecheck property to test the distributive law
of arithmetic (Figure~\ref{fig-02-01}, page \pageref{fig-02-01}).
Use Proof Pad to run your test.

\Exercise
Define doublecheck properties to test
consistency between clock
arithmetic and ordinary arithmetic
as described in 
Aside~\ref{modular-arithmetic} (page \pageref{modular-arithmetic}).
Use Proof Pad to run your tests.

\Exercise
The ACL2 operator ``reverse'' delivers a list whose
elements are in the reverse order of those in its operand.
For example (reverse (list 1 2 3)) is (list 3 2 1).
Find an equation that expresses the value of (reverse (append $xs$ $ys$))
in terms of (reverse $xs$) and (reverse $ys$).
Define a property based on your equation and
use Proof Pad to test it.

\end{ExerciseList}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
