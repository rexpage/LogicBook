\chapter{Software Testing and Prefix Notation}
\label{ch:software-testing-prefix-notation}

\todo{ COMMENT ONLY, NO TODO Rex16Sep2017
Removed reciprocals stuff
see on Rex's local copy if needed: ch03WITHRECIPROCALSSTUFFINCASEWEREVERTTOIT16Sep2017.tex
}

We will be using a software development environment that automates parts of the software testing process.
To use it, we can define tests that check results corresponding to inputs provided directly in the test.
Or, we can ask the system to generate certain kinds of random data check results
against logic formulas specifying properties that we expect of the results.

\begin{aside}
Proof Pad is a tool that provides a convenient way
to write, test, and reason about programs
written in the ACL2 dialect of a programming language called Lisp.
ACL2 includes a mechanized logic that
supports rigorous checking of the reasoning process,
and we will use it for that purpose starting in this chapter.

We will begin to use Proof Pad in this chapter,
so you should install it on your computer.
To install Proof pad, follow the instructions at \url{http://proofpad.org}.
If that link fails, look for ``Proof Pad''
with your web search engine.
They are well-known systems and should be easy to find.
They are free, too.
\label{aside:proof-pad}
\caption{Proof Pad and ACL2}
\end{aside}

To get the syntax straight, let's specify some direct tests that Proof Pad
can carry out for the addition operator.
The following tests check some equations that we expect to be true:
$2 + 2 = 4$, $5 + 7 = 10 + 2$, etc.

\begin{Verbatim}
(include-book "testing" :dir :teachpacks)
(check-expect (+ 2 2) 4)
(check-expect (+ 5 7) (+ 10 2))
(check-expect (+ 27 6) (+ (+ 23 5) (+ 2 2)))
\end{Verbatim}

This notation looks strange, with formulas like (+ $2$ $2$) instead of $2 + 2$.
ACL2 uses a prefix notation to denote operations, rather than the infix notation
that you are accustomed to.
In ACL2's prefix notation, a computational formula starts with a parenthesis,
followed by the operator it invokes.
The operator comes first (as a ``prefix''), then the operands.
Infix notation places the operator between the operands,
and prefix puts it before the operands.

That seems simple enough, but it gets gradually more unfamiliar
as the formulas get more complicated.
For example, a formula for the sum of $x$ and three times $y$, $(x + 3*y)$,
comes out as (+ $x$ ($*$ $3$ $y$)) in prefix form.
This will take a little getting used to,
but is a lot easier to get good at than
most of the stuff you have been studying.
We hope you will be willing to accept it as just another way of writing formulas.
One advantage is the formulas are, by default, fully parenthesized,
so there is never any question about what operands go with which operators.
Some people end up liking the prefix format better than infix.
We will use both, in different contexts, depending on whether
we're doing paper-and-pencil reasoning or formal, mechanized logic.

Another strange element is the include-book directive.
The facility for tests of this kind resides in an ACL2 book
known as "testing", which in turn resides in a directory known
as :teachpacks (with the leading colon).
The include-book directive tells the system
the name of the testing package and where to find it.
This boilerplate is needed (including the keyword :dir, with the leading colon)
whenever you want to use check-expect testing,
even though we won't repeat it in all of our examples.
If you install Proof Pad and put these tests in a file
with the .lisp extension (plusoptests.lisp, for example),
you can use Proof Pad to run the tests.
The first tests two pass without fanfare,
but the third test has a mistake.
We should not expect that $27 + 6 = (23 + 5) + (2 + 2)$.
The system reports that the assertion failed.
If you change the 6 to 5, the test will pass, as it should.
Normally, when we run tests, we want to know whether the
operator is doing the right thing,
but in this case the operator ($+$) was fine.
It was the test that was wrong.

Direct, one-off, check-expect tests
are a good way to get started, but
we will want to test more general properties that we specify with logic formulas.
Proof Pad facilitates that kind of testing with a package called doublecheck
that generates random data to run against a predicate
(that is, a formula representing a true/false value).
To demonstrate the idea, consider testing the addition operator to see if
it conforms to the associative law for addition: $(x + (y + z)) = ((x + y) + z)$
(\{+ associative\}, Figure~\ref{fig-02-01}, page \pageref{fig-02-01}).
To do that, we define a property as an equation
and directs Proof Pad to generate some random numbers and
report whether or not the equation holds on all of the random data.

\begin{Verbatim}
(include-book "doublecheck" :dir :teachpacks)
(defproperty +associative-test
  (x :value (random-integer)
   y :value (random-integer)
   z :value (random-integer))
  (= (+ x (+ y z))
     (+ (+ x y) z)))
\end{Verbatim}

The Proof Pad environment ``doublecheck'' package,
like the ``testing'' package,
resides in the teachpacks directory,
and an include-book directive is required so that Proof Pad where to find it.

A property definition with doublecheck begins with a parenthesis, then the keyword
defproperty and a name for the property to be tested,
which is ``+associative-test'' in this case.\footnote{The
rules for naming things in ACL2 are lax, compared to many
programming languages. Names can be made up of letters and digits, of course,
but can also include some special characters,
such as plus signs and colons (not semicolons, though).}
A sequence of data generator specifications follows the name of the property.
The entire sequence is enclosed in parentheses,
and each specification has three parts: a name, the keyword :value (with the leading colon),
and a generator, also enclosed in parentheses.
In this case, the definition says to use random integers.
Doublecheck is able to generate many kinds of random data,
and we will gradually introduce different data generators as the story progresses.
Finally, a predicate formula specifies the test.
In this case, the predicate is an equation,
written of course in prefix notation.

Let's look at another example.
\label{list-op-informal}
The operator ``list'' creates a list of its operands
(any number of operands), and
\label{append-op-informal}
the operator ``append'' concatenates two lists.
A few check-expect tests may clarify what the append operator does.
We defer, for now, more formal specifications for the append and list operators.

\begin{Verbatim}
(check-expect (append (list 1 2 3 ) (list 4 5)) (list 1 2 3 4 5))
(check-expect (append (list 9 8 7) (list 6) (list 9 8 7 6))
(check-expect (append (list 11 7) (list 2 5 3)) (list 11 7 2 5 3))
(check-expect (append (list 2 0) (list 1 8)) (list 2 0 1 8))
\end{Verbatim}

We would anticipate that the length of a concatenation of two lists
would be the length of the first list plus the length of the second.
\label{len-op-informal}
Using the ``len'' operator, which computes the length of a list,
we can state this property in a doublecheck test.
Later, we will prove this relationship between append and len,
but for the moment we confine ourselves to stating properties
and asking Proof Pad to check them against random data.

\label{additive-lengths-test}
\begin{Verbatim}
(defproperty additive-law-of-concatenation-test
  (xs :value (random-list-of (random-integer))
   ys :value (random-list-of (random-integer)))
  (= (len (append xs ys))
     (+ (len xs) (len ys))))
\end{Verbatim}

\begin{aside}
A ``natural number'' is a whole number (that is, an integer)
that is zero or bigger.
Some mathematical treatments start the naturals at one,
rather than zero, but in the computing domain,
it simplifies a lot of formulas to start the natural numbers at zero.
\caption{Natural Numbers}
\label{natural-number-def}
\end{aside}

When we discuss computer arithmetic, we will need to know something about
arithmetic on finite sets of numbers, and the ``mod'' operator will play a crucial role.
\label{mod-function}
The mod operator takes two operands and
delivers the remainder in the division of the first operand by the second.
ACL2 does not restrict the operands to the set of natural numbers,
but in this discussion, we are going to stick with that domain.
Think long division: divisor, dividend, quotient,
remainder . . . third-grade stuff.

Let's test drive the mod operator, starting with
some simple checks, such as using mod
to compute the remainder when dividing by two,
which will produce zero for even numbers and one for odd numbers.

\begin{Verbatim}
(check-expect (mod 12 2) 0)
(check-expect (mod 27 2) 1)
\end{Verbatim}

Here are a few more sanity checks, this time with three as the divisor.

\begin{Verbatim}
(check-expect (mod 14 3) 2)
(check-expect (mod  7 3) 1)
(check-expect (mod 18 3) 0)
\end{Verbatim}

\begin{aside}
Modular arithmetic (sometimes called ``clock arithmetic'')
deals with integers in a fixed range, $0 \dots (m - 1)$,
where $m$ is an integer greater than zero known as
the ``modulus''.
If $x$ is an integer, the formula ($x$ mod $m$) stands for
the remainder in the division of $x$ by $m$.

Modular addition, subtraction, and multiplication are
are consistent with ordinary arithmetic.
That is, the sum of two numbers, mod $m$,
is the same as the sum, mod $m$, of the corresponding numbers
in the ``mod $m$'' range.
The same is true of subtraction and multiplication.

\begin{quote}
($(x + y)$ mod $m$) = ((($x$ mod $m$) $+$ ($y$ mod $m$)) mod $m$) \\
($(x - y)$ mod $m$) = ((($x$ mod $m$) $-$ ($y$ mod $m$)) mod $m$) \\
($(x \times y)$ mod $m$) = ((($x$ mod $m$) $\times$ ($y$ mod $m$)) mod $m$)
\end{quote}

The ACL2 operator ``mod'' converts numbers to the modular range
for a given modulus. That is, (mod $x$ $m$) delivers the remainder
in the division of $x$ by $m$.
The divisor (second operand) must be non-zero.
ACL2 does not restrict the operands to natural numbers,
but the discussion here assumes that they are.
\caption{Clock Arithmetic}
\label{modular-arithmetic}
\end{aside}

We can put ``mod''
through its paces on a large number of tests using doublecheck,
but for that we will need to come up with relationships
that express more general properties of division and remainders.
One such property is that the remainder doesn't change
when the divisor is added to the dividend.

\begin{Verbatim}
(defproperty mod-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (= (mod dividend divisor)
       (mod (+ dividend divisor) divisor))))
\end{Verbatim}

Generating random data is an art.
In this example, we have made sure the divisor isn't zero
by adding one to a natural number.
Since negative numbers aren't natural numbers, adding one
to a natural number ensures that the sum is non-zero.
\label{let-example-brief-explain}
The definition of the property uses a ``let*'' formula,
which provides a way to attach names to values temporarily
(Aside \ref{let*-def}, page \pageref{let*-def}).
In this case, the let* says that
the name ``divisor'' will be used to stand for
the value represented by the formula (+ divisor-minus-1 1).
To see the testing facility in action,
define the ``mod-test'' property in a .lisp file,
and use Proof Pad to run the tests.

\begin{aside}
A \emph{let* formula} attaches names to values
to be used within the scope of the let* formula.
The scope of the let* opens with a parenthesis followed
by the keyword ``let*''. It continues with
a sequence of name-value bindings, and ends with
a formula for the value to be delivered by the let*
and a closing parenthesis matching the one just prior
to the let* keyword.

Each binding has two elements: first a name,
then a formula specifying a value to be associated with the name.
Any of the names attached to values in the bindings
can be used subsequently in scope of the let* to denote those values.
There can be any number of bindings.
The most common use of ``let*'' is to give names
to values needed more than once in a computation,
but sometimes it's used just to give mnemonic names
to significant elements in a computational formula.

The parentheses in a let* formula are tricky.
Each individual name-value binding is enclosed in parentheses,
and the whole sequence of bindings is closed in another set
of parentheses. In addition, the entire let* formula
is enclosed in its opening and closing parentheses.
The let* formula denotes the value specified
in the formula that comes at the end of the let*, after the 
name-value bindings.
\caption{Naming Local Values with Let*}
\label{let*-def}
\end{aside}

Another property of the mod operator
in the domain of natural numbers
is that the remainder
is always smaller than the divisor.
That is, (mod dividend divisor) < divisor.
The following property definition uses
the doublecheck testing facility
to test whether the mod function delivers values in this range.

\begin{Verbatim}
(defproperty mod-upper-limit-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (< (mod dividend divisor) divisor)))
\end{Verbatim}

In this test, the property is not expressed as an equation,
but as an inequality
specified with the less-than operator ($<$).
As always, the formula puts the operator in the prefix position,
in front of its operands.
For practice, add this property to the .lisp file with the other tests and run it.

Another fact about remainders in division in the domain of natural numbers is that
they are non-negative integers (that is, natural numbers).
We can use the logical-and operator (``and'' is the ACL2 name for $\wedge$)
to combine the upper-limit test with the natural-number test.
in one property definition.
\label{natp-op}
The value of the formula ``(natp $x$)'' is true
if $x$ is a natural number and false if it isn't.

\label{natp-axiom-formal}
\begin{center}
Axiom \{\emph{natp}\} \\
(natp $x$) $=$ $x$ \emph{is a natural number}
\end{center}

\begin{Verbatim}
(defproperty mod-range-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (and (natp (mod dividend divisor))
         (< (mod dividend divisor) divisor))))
\end{Verbatim}

\begin{aside}
ACL2 provides two operators,
ceiling and floor, that divide one number by another,
then round up or down to an integer value.
In algebraic formulas, special brackets known as
floor and ceiling brackets indicate the direction of rounding.
Ceiling brackets (like square brackets with the bottom chopped off)
indicate the next integer that is the same as or larger than
the enclosed value.
Floor brackets (square brackets without the top part)
go in the other direction, down to an integer
that doesn't exceed the enclosed value.

\begin{center}
\begin{tabular}{lll}
(ceiling $x$ $y$)& $= \lceil x  \div y \rceil $ \emph{quotient rounded up}   \\
(floor $x$ $y$)  & $= \lfloor x \div y \rfloor$ \emph{quotient rounded down} \\
\end{tabular}
\end{center}

\caption{Floor and Ceiling Operators, Floor and Ceiling Brackets}
\label{floor-def}
\label{ceiling-def}
\label{floor-ceiling-ops-brackets}
\end{aside}

There are two parts to the result
of dividing one number by another: the quotient and the remainder.
The mod operator delivers the remainder,
and an operator called FLOOR (Aside~\ref{floor-ceiling-ops-brackets})
delivers the quotient.
The quotient is always strictly smaller
than the dividend when the divisor is bigger than one
and the dividend is a non-zero, natural number.
The following test checks for that property.
The random-value generator for the divisor
makes sure the divisor exceeds one by adding two
to a natural number.
Similarly, we make sure the dividend isn't zero by adding one.

\label{quotient-less-than-dividend-test}
\begin{Verbatim}
(defproperty quotient-less-than-dividend-test
  (divisor-minus-2   :value (random-natural)
   dividend-minus-1  :value (random-natural))
  (let* ((divisor  (+ divisor-minus-2 2))   ; divisor  > 1
         (dividend (+ dividend-minus-1 1))) ; dividend > 0
    (< (floor dividend divisor)
       dividend)))
\end{Verbatim}

Checking the result of a division is a matter
of multiplying the quotient by the divisor and adding the remainder.
If this fails to reproduce the dividend,
something has gone wrong in the division process.
The following property tests this relationship
between the mod and floor operators.
It needs to use the multiplication operator, which is denoted by an asterisk.

\label{division-check-test}
\begin{Verbatim}
(defproperty division-check-test
  (divisor-minus-1 :value (random-natural)
   dividend        :value (random-natural))
  (let* ((divisor (+ divisor-minus-1 1))) ; avoid zero divisor
    (= (+ (* divisor (floor dividend divisor))
          (mod dividend divisor))
       dividend)))
\end{Verbatim}

We hope by now you are starting to get comfortable with prefix notation
and the Proof Pad test facilities.
The exercises will give you a chance to practice.

\begin{ExerciseList}
\Exercise Define a test of the floor operator
that checks to make sure its value is a natural number
when its operands are natural numbers,
and the divisor (second operand) is not zero.
Use Proof Pad to run the test.

\Exercise The ``max'' operator chooses the larger of two numbers:
(max 2 7) is 7, (max 9 3) is 9.
Define a doublecheck property that tests to make sure
(max $x$ $y$) is greater than or equal to (>=) both $x$ and $y$.
Use Proof Pad to run tests of the property.

\Exercise
Define a doublecheck property to test the distributive law
of arithmetic (Figure~\ref{fig-02-01}, page \pageref{fig-02-01}).
Use Proof Pad to run your test.

\Exercise
Define doublecheck properties to test
consistency between clock
arithmetic and ordinary arithmetic
as described in
Aside~\ref{modular-arithmetic} (page \pageref{modular-arithmetic}).
Use Proof Pad to run your tests.

\Exercise
The ACL2 operator ``reverse'' delivers a list whose
elements are in the reverse order of those in its operand.
For example (reverse (list 1 2 3)) is (list 3 2 1).
Find an equation that expresses the value of (reverse (append $xs$ $ys$))
in terms of (reverse $xs$) and (reverse $ys$).
Define a property based on your equation and
use Proof Pad to test it.

\end{ExerciseList}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "book"
%%% End:
